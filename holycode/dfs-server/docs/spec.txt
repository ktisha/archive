=dfs-server=
О функциональном назначении сервера подробнее читайте в функциональной спецификации _(ещё не написано)_.
Основная задача dfs-server это предоставить возможность пользователям входить в систему и управлять своими файлами.
Имеются следующие возмножности: загружать файлы, искать среди них, скачивать, удалять. Для удобной организафии файлов существует понятие списка файлов. Список файлов может содержать только файлы (но не другие списки). Пользователь может иметь неограниченное количесво списков файлов.
Основная особенность состоит в том, что у пользователя есть возможность указать степень надежности хранения файла (число копий файла в системе). 

Главная особенность состоит в том, что файлы хранятся не на серевере, а на некотрых хранилищах. 

Таким образом, задача разбивается на три независимых модуля:
 * `server`
 * `filesystem-provider`
 * `distributed-filestorage`


=server=
Обеспечивает возможность присоединяться по `tcp` и выполнять некоторые _`task`_.
Большая часть классов находится в модуле *`server`*. `main class` это *`server.Listener`*


==server.Listener==
Этот класс обеспечивает взаимодействие клиентской стороны с серверными сервисами.
Основное назначение класса: прослушивать заданный порт, при получении входящего соединения обрабатывать его в отдельном потоке с помощью server.Connector

При запуске программы в первую очередь происходит проверка наличия и доступность необходимых библиотек, создается лог _(проверка не реализована)_.
После этого начинается прослушивание заданного порта, здесь исполюзуется библиотека `java.nio`. При получении входящего соединения, происходит проверка: допустимо ли соединение с этого `IP`. Для этого используется класс *`security.Defender`*.

Если соединение разрешено, *`server.Listener`* создает объект *`server.Connector`* и передает в качестве аргумента `SocketChannel`. *`server.Connector`* реализует интерфейс `Runnable`, созданный объект передается на исполнение в `CachedThreadPool` (из `java.util.concurrent`). После этого серевер продолжает прослушивание порта.


==server.Connector==
Этот класс обеспечивает взаимодействие клиентской стороны с серверными сервисами.
Основное назначение класса: прочитать запрос, распарсить его, построить task, выполнить задачу, отправить ответ, полученный в результате работы task, завершить соедение.

Взаимодействие осуществляется посредством астракции _`task`_ -- это интерфейс *`task.Task`*.
Вополнение кода *`server.Connecor`* происходит в отдельном потоке, в методе *`server.Connecor.run()`*.
В начале выполнения этого метода происходит получение `I/O` потоков из сокета.

Далее управеление пердаётся в метод server.Connector.process() . Здесь считывается запрос из потока, с помощью HeaderProvider.Reader.read() . Данный метод в начале считывает header сообщения (4 байта), чтобы вычислить размер следующего запроса. После считывает и сам запрос.
Затем просходит парсинг xml запроса, после с помощью фабрики task.TaskFactory просходит построение task и выполнение его методом task.doTask() , который возвращает ответ. Этот ответ возвращает метод server.Connector.process().

Если server.Connector.process() не выбросил исключение, то ответ задачи записывается в сокет, завершается соединие.


=task=
Этот пакет содержит все задачи, котрые предполагается выполнять на сервере.

==task.Task==
Это интерфейс. Если необходимо создать некоторую задачу, необходимо реализовать этот интерфейс в своём классе, а также описать процесс создания этой задачи в фабрике task.TaskFactory . Не


=remotefs=

