<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
   "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="ru" lang="ru">
<head>
<meta http-equiv="Content-Type" content="text/html;charset=utf-8"/>

<meta name="sprypayUrlChecker" content="sprypay_fpraOIA7CnzFuVkwTFol4GEMpK3RdzExgx4SCKayofR7wwGQvRBfNE2QUww9JV84_1763">

<title>Алгоритм обеспечения исключительного доступа к коммутатору rapidio</title>     <style>
	 .sps {
        padding-left: 20px;
        line-height: 20px;
	   padding:1px;
	   margin:0px;
     }

     .hed {
       color: #666666;
       font: bold;
       font-size: 14px;
       border: 1px solid;
	   padding:1px;
	   margin:0px;
     }

     .trhed {
       padding: 25px;
     }
	 
	 .td_arch {
	   margin:0px;
	   padding:5px;
	  }
	 
	 .in_journal {
	  border:3px solid #fff;
	 }

	 .in_journal:hover {
	  border:3px solid #aaaaaa;
	 }
	 
     .ndisp {
         display:none;
     }
     
	  </style>

<!--[if IE]>
<style>
.outer, .wrapper, .minwidth {
	zoom: 1;
}

</style>
<![endif]-->

<!--[if lt IE 7]>
<style>
.minwidth {
	border-left: 504px solid #fff;
}
.wrapper {
	margin-left: -504px;
	position: relative;
}
</style>
<![endif]-->

<link href="css/layout_2col_right_31.css" rel="stylesheet" type="text/css"/>	  

<link href="style.css" type="text/css" rel="stylesheet" />
<link rel="alternate" type="application/rss+xml" title="RSS" href="http://www.swsys.ru/rss">

<!--[if lte IE 7]>
<link href="css/patches/patch_2col_right_31.css" rel="stylesheet" type="text/css" />
<![endif]-->

    <script src="script/CalendarPopup.js"></script>


<script>

function submit_login() {
 if ( document.login_form.login.value != "" && document.login_form.password.value != "" ) { 
  document.login_form.activity.value = "AUTORIZ";
  document.login_form.submit();
  }
 else 
 {
 alert("Введите логин и пароль"); 
 document.login_form.username.focus();
 }
 
}

 function to_registry() {
	document.login_form.action = "event.php?page=registry";
    document.login_form.submit();
 }

 function to_search() {
    document.search_form.submit();
 }

</script>

</head>
<body>








<div id="page_margins">
	<div id="page">
		<div id="header">
			<div id="topnav">
				  <form action="event.php?page=search&order=date"  method="post" id="search-theme-form" name="search_form">
<div><div id="search" class="container-inline"><div class="form-item">
 <input type="text" maxlength="128" name="search" id="edit-search-theme-form-keys"  size="15" value="поиск..." title="Введите слова для поиска." class="form-text" onBlur="if ( this.value == '' ) this.value = 'поиск...';" onFocus="if ( this.value=='поиск...' ) this.value='';"/>
 <a href="#" onclick="Javascript: if ( document.search_form.search.value == 'поиск...' ) { alert('Введите поисковый запрос!') } else document.search_form.submit()">Найти</a>
</div>
</div>
</div></form>
				<div id="subsearch"><span><a href="index.php?page=extsearch">Расширенный поиск</a> / <a href="index.php?page=sitemap">Карта сайта</a></span></div> </div>
			<span style="cursor:pointer" onclick="Javascript:document.location = 'index.php'" class="zag">Международный журнал</span>
			<h1 style="cursor:pointer; width:auto" onclick="Javascript:document.location = 'index.php'">Программные продукты и системы</h1>
		   
			</div>
		<!-- begin: main navigation #nav -->
		<div id="nav"> <a id="navigation" name="navigation"></a>
			<!-- skiplink anchor: navigation -->			
		</div>
		<!-- end: main navigation -->
		<!-- begin: main content area #main -->
		<div id="main">
			<!-- begin: #col1 - first float column -->
			<div id="col1">
				<div id="col1_content" class="clearfix">
					<div id="menu" class="r-block">
						<h2>Разделы сайта</h2>
						<ul id="submenu">
						
						<li style="white-space:nowrap;margin-left:-15px"><a href="index.php?page=1">О журнале</a></li><li style="white-space:nowrap;margin-left:-15px"><a href="index.php?page=3">Редколлегия</a></li><li style="white-space:nowrap;margin-left:-15px"><a href="index.php?page=12">Научные направления</a></li><li style="white-space:nowrap;margin-left:-15px"><a href="index.php?page=9">Свежий выпуск</a></li><li style="white-space:nowrap;margin-left:-15px"><a href="index.php?page=19">Список авторов выпуска</a></li><li style="white-space:nowrap;margin-left:-15px"><a href="index.php?page=10">Архив выпусков</a></li><li style="white-space:nowrap;margin-left:-15px"><a href="index.php?page=11">Подписка</a></li><li style="white-space:nowrap;margin-left:-15px"><a href="index.php?page=5">Авторам и издателям</a></li>						
					  </ul>	
					</div>	

     
					<div id="login" class="mainborder r-block">
                    
                    <h2>Вход</h2>				
				   <form action="event.php?page=article"  method="post" id="login-form" name="login_form">
<div id="login-form-div">
	<div class="form-item"><input type="text" maxlength="128" name="login" size="15" value="" title="" class="form-text" /></div>
 <div class="form-item"><input type="password" maxlength="128" name="password" size="15" value="" title="" class="form-text"/></div>
 <input type="hidden" name="activity" />
 
        <label for="save_pas"><input type="checkbox" style="width:25px;border:none;" name="save_pas" id="save_pas" />Запомнить</label><br />

  <div id="login-button"><input style="border:none;width:46px;height:45px" type="image" src="images/login-button1.gif" onclick="submit_login();"></div> 
<!-- <input type="submit" /> -->
</div></form>
				 
				<span><a href="index.php?page=recovery">Забыли пароль?</a> / <a href="#" onclick="to_registry();">Регистрация</a></span>				  
                         
                 

                 
                 
				  </div>


                  
                  

           
  
  <div style="padding: 5px 0px 0px 45px">     
<script type="text/javascript"><!--
google_ad_client = "pub-6573451237838679";
/* Вторая страница право */
google_ad_slot = "0208394776";
google_ad_width = 120;
google_ad_height = 240;
//-->
</script>
<script type="text/javascript"
src="http://pagead2.googlesyndication.com/pagead/show_ads.js">
</script>                  
     </div>
     
      
				  
				  
				                    <div id="next-after" class="r-block">
                    <h2>Добавить в закладки</h2>
                    <script src="/ok2.js" type="text/javascript"></script>
                  </div>
                  
				  <div id="next-after" class="r-block">
					<h2>Следующий номер</h2>
					<div id="sled-nomer" class="floatbox"><span class="simv-nomer">№</span>1</div>
					<div id="sled-nomer-text">
					Выходит:<br/>
					<div> 18 Марта 2011 </div>
                     				  </div>
				 </div>
				  <div class="r-block" id="arh">
					<h2>Выпуски</h2>

 						<div class="god">2010</div><ul><li><a href="index.php?page=search&order=date&journal=92">№4 Декабрь 2010</a></li><li><a href="index.php?page=search&order=date&journal=91">№3 Сентябрь 2010</a></li><li><a href="index.php?page=search&order=date&journal=90">№2 Май 2010</a></li><li><a href="index.php?page=search&order=date&journal=89">№1 Март 2010</a></li></ul>
				
						<div align="center" style="margin-top:0px; padding:0px" ><a style="font-size:12px" href="index.php?page=10">все выпуски</a></div>
						<div align="center" style="margin-top:0px; padding:0px" ><a style="font-size:12px" href="index.php?page=all_article">все статьи</a></div>
				  </div>
				  
				  
				</div>

                  <div id="next-after" class="r-block">
                    <h2>Новости</h2>  
                                 
                        <p>     
                        <a href="index.php?page=show_news&id=117">В Международном университете природы, общества и человека (г. Дубна) предложен алгоритм генерации растущих сетей с нелинейным предпочтительным присоединением, конкуренцией и удалением узлов</a> [15.12.2010]
                        <br/>
                                     
                        <p>     
                        <a href="index.php?page=show_news&id=116">В Группе компаний «Генезис знаний» (г. Самара) предложено решение по построению и внедрению мультиагентной системы распределения производственных ресурсов МАС «Оптимизатор»</a> [08.12.2010]
                        <br/>
                                     
                        <p>     
                        <a href="index.php?page=show_news&id=115">В Волгоградском государственном техническом университете разработана модель обучающей системы в области автомобильного транспорта</a> [01.12.2010]
                        <br/>
                                                
                        <div style="text-align:center"><a href="index.php?page=show_news">читать все новости</a></div>
                        
                                          </div>

					<div class="r-block" style="text-align:center;padding:0px;margin:0px;">
					   <a style="text-decoration:none;" href="rss/"><img alt="RSS" title="RSS" src="images/rss.gif"/><br/>
						<div style="text-decoration:underline;display:inline">Подписаться на RSS</div></a>
					</div>
                    
                  

			</div>

       

			<!-- end: #col1 -->
			<!-- begin: #col3 static column -->
			<div id="col3">
				<div id="col3_content" class="clearfix"> <a id="content" name="content"></a>





<script>

            function go_event_comment(act, id)
            {
                 document.s_article.activity.value = act;
                 document.s_article.id.value = id;
                document.s_article.submit();
            }


            function go_event_vote(act, id)
            {
                 document.v_article.activity.value = act;
                 document.v_article.id.value = id;
                document.v_article.submit();
            }
            
            
</script>

<h2 style="margin-bottom:3px">Алгоритм обеспечения исключительного доступа к коммутатору rapidio</h2><div style="margin-bottom:10px"><strong>Mutual exclusion algorithm for rapidio switch access</strong></div>Статья опубликована в выпуске журнала № 4 за 2010 год. [ 09.12.2010 ]<br/><strong>Аннотация:</strong><em style="font-size:8pt">Предлагается алгоритм обеспечения исключительного доступа к коммутатору RapidIO, устойчивый к выходу оконечных устройств из строя. Алгоритм предназначен для использования в случаях, когда настройка коммуникаци-онной среды RapidIO производится сразу несколькими оконечными устройствами и требуется исключить возможность одновременного доступа нескольких оконечных устройств к одному коммутатору.</em><br /><strong>Abstract:</strong><em style="font-size:8pt">An algorithm is proposed for providing mutual exclusion access of several RapidIO nodes to a single switch while RapidIO switching fabric is being initialized by a number of nodes. The algorithm is tolerant to node failures.</em><table border="0" width="100%" style="width:100%;"> 
            <tr>
             <td colspan="2"><b>Автор: </b><a href="index.php?page=infou&id=5926">Бакулин А.А. ()</a> -    </td>            
         </tr> 
            <tr>
             <td><b>Ключевые слова: </b><a href="index.php?page=infotg&id=1761">взаимное исключение</a>, <a href="index.php?page=infotg&id=115">алгоритм</a>, <a href="index.php?page=infotg&id=1760">rapidio</a><br /></td> 
           </tr>
            <tr>
             <td><b>Keywords: </b><a href="index.php?page=infotg&id=1761"></a>, <a href="index.php?page=infotg&id=115">algorithm</a>, <a href="index.php?page=infotg&id=1760"></a><br /></td> 
           </tr>   

 <tr>
             <td>Средний балл статьи: - <br />Всего комментариев: 0<br />Количество просмотров: 23<br />   
             </td> 
            <td align="right"><a target="_blank" href="/print/article_print.php?id=2606">Версия для печати</a></td>
         </tr>           
          </table>

<br/>

    
    
    <script>
      function set_size(vl) {
         document.getElementById('id_art').style.fontSize = vl;
      }
      function set_font(vl) {
         document.getElementById('id_art').style.fontFamily = "'" + vl + "'";
      }
    </script>
    
      <div style="width:100%;background:#E0E0E0;padding:5px;border:1px solid #D0D0D0">
         <form>
           Размер шрифта:
            <select name="f_size" onchange="set_size(this.value)">
               <option value="10px">10 px</option>
               <option value="12px" selected="selected">12 px</option>
               <option value="14px">14 px</option>
               <option value="16px">16 px</option>
               <option value="18px">18 px</option>
               <option value="24px">24 px</option>
            </select> &nbsp; &nbsp; &nbsp;
           Шрифт:
            <select name="f_name" onchange="set_font(this.value)">
               <option value="Arial">Arial</option>
               <option value="Trebuchet MS" selected="selected">Trebuchet MS</option>
               <option value="Times New Roman">Times New Roman</option>
               <option value="Verdana">Verdana</option>
               <option value="Arial Narrow">Arial Narrow</option>
               <option value="Tahoma">Tahoma</option>
            </select>
            
         </form>
        </div>
         <br />
    <table bgcolor="#FFFFFF"><tr><td><div id="id_art" style="font-size:12px;"><p>@Сеть передачи данных RapidIO [1] состоит из связанных между собой оконечных устройств (ОУ, или просто устройств) и коммутаторов. Коммутаторы образуют коммуникационную среду, обеспечивающую прозрачную доставку пакетов между ОУ. В сети RapidIO невозможна доставка пакетов между двумя узлами по нескольким маршрутам, поэтому сообщения, отправленные одним устройством одному адресату, доходят в соответствии с порядком их отправки. Однако пакет, отправленный одним устройством, может дойти до адресата раньше, чем пакет, отправленный до него с другого устройства.</p>
<p>&nbsp;</p>
<p>Чтобы коммутаторы могли корректно выполнять свою работу, при инициализации системы их необходимо соответствующим образом настроить, то есть определить последовательность операций чтения и записи над его регистрами путем отправки коммутатору служебных сообщений с запросами на чтение и запись.</p>
<p>Если какой-либо коммутатор не будет настроен, система может стать неработоспособной. Поэтому в целях отказоустойчивости настройку коммутаторов системы могут осуществлять одновременно несколько ОУ; если некоторые ОУ выйдут из строя, перезагрузятся или просто не будут включены, настройку коммутаторов выполнят остальные.</p>
<p>Процесс настройки, одновременно выполняемый несколькими ОУ, подразумевает возможность чередования запросов к одному коммутатору со стороны различных ОУ. Это может привести к нарушению согласованности состояния коммутатора и в результате к невозможности коммуникационной среды доставлять данные между ОУ. Следовательно, необходим алгоритм обеспечения взаимоисключающего доступа каждого ОУ к каждому коммутатору.</p>
<p>Назовем конечную последовательность действий ОУ по настройке одного коммутатора, вмешательство в которые со стороны других ОУ не допускается, критической секцией (КС). Под исключительным доступом будем понимать, что, во-первых, никакие два ОУ не могут выполнять критическую секцию одновременно и, во-вторых, если в определенный момент несколько ОУ решили выполнить критическую секцию, то через некоторое конечное время одно из этих ОУ должно начать ее выполнение.</p>
<p>Для упрощения реализации исключительного доступа каждый коммутатор содержит особый регистр блокировки [2] (Host Base Device ID Lock CSR, или lock), для которого характерно следующее поведение. Если регистр находится в исходном (сброшенном) состоянии, в него можно записать любое значение. После этого регистр можно сбросить обратно в исходное состояние повторной записью содержащегося в нем значения; попытка записи любого другого значения при этом игнорируется. Несмотря на свое название, регистр блокировки не препятствует доступу к коммутатору со стороны любых устройств, какое бы значение он ни содержал. Устройствам доступны и другие регистры коммутатора, но все они, за исключением регистра метки (Component Tag CSR, или tag), имеют особое назначение и не могут использоваться для записи в них произвольных значе- ний [2]. Бит Discovered в регистре Port General Control CSR [3] коммутатора устанавливается ОУ, успешно настроившим коммутатор. Анализируя значение этого бита, ОУ принимают решение о необходимости настройки коммутатора.</p>
<p>В ходе настройки коммутаторов маршрутизация пакетов в сети RapidIO еще не работает должным образом, поэтому ОУ не могут напрямую общаться между собой, и обмен информацией между ними возможен только через регистры коммутаторов.</p>
<p>Решим следующую задачу. Пусть имеется N оконечных устройств с уникальными целыми положительными идентификаторами, имеющих доступ к двум регистрам одного коммутатора &ndash;блокировки и метки. Каждое ОУ выполняет программу, в которую входят фрагменты, называемые критической секцией и некритической секцией. Любое ОУ может выйти из строя в какой-то момент в процессе своей работы.</p>
<p>Предположим, что верны следующие утверждения.</p>
<p>1.&nbsp;&nbsp; Время выполнения критической секции ограничено сверху.</p>
<p>2.&nbsp;&nbsp; В случае выхода из строя ОУ просто прекращает свою работу, не выполняя при этом действий, не предусмотренных программой.</p>
<p>3.&nbsp;&nbsp; Никакие два запроса на чтение или запись регистров коммутатора не выполняются одновременно. Относительный порядок запросов, отправленных одним ОУ, сохраняется.</p>
<p>4.&nbsp;&nbsp; Каждый шаг алгоритма, включая чтение или запись регистра коммутатора, выполняется за ограниченное сверху время для данной конфигурации системы.</p>
<p>Предположение 2 не допускает возникновения такого распространенного вида отказа, как перезагрузка.</p>
<p>Был разработан алгоритм программы ОУ, который при выполнении перечисленных предположений удовлетворяет:</p>
<p>&middot;&nbsp;&nbsp;&nbsp;&nbsp; требованию взаимного исключения: никакие два ОУ не могут выполнять критическую секцию одновременно;</p>
<p>&middot;&nbsp;&nbsp;&nbsp;&nbsp; требованию прогресса: если несколько ОУ хотят выполнить критическую секцию, то количество обращений к памяти, после которого одно из ОУ начнет выполнение критической секции, ограничено сверху для данной конфигурации системы.</p>
<p>Эти требования допускают, что некоторое ОУ, желающее выполнить критическую секцию, может ожидать своей очереди бесконечно.</p>
<p>Представим разработанный алгоритм.</p>
<p>0&nbsp;&nbsp;&nbsp;&nbsp; oldlock = -1</p>
<p>Lock:</p>
<p>1&nbsp;&nbsp;&nbsp;&nbsp; mylock = NewMylock()</p>
<p>2&nbsp;&nbsp;&nbsp;&nbsp; WRITE(lock, mylock)</p>
<p>3&nbsp;&nbsp;&nbsp;&nbsp; READ(lock, lk)</p>
<p>4&nbsp;&nbsp;&nbsp;&nbsp; if lk == oldlock</p>
<p>5&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; goto Force</p>
<p>6&nbsp;&nbsp;&nbsp;&nbsp; if lk == mylock</p>
<p>7&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; goto Crit</p>
<p>8&nbsp;&nbsp;&nbsp;&nbsp; if lk == EMPTY</p>
<p>9&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; goto Lock</p>
<p>10&nbsp; &nbsp;&nbsp;oldlock = lk</p>
<p>11&nbsp;&nbsp;&nbsp; WAIT(ReleaseTimeout)</p>
<p>12&nbsp;&nbsp;&nbsp; WRITE(tag, 0)</p>
<p>13&nbsp;&nbsp;&nbsp; goto Lock</p>
<p>Force:</p>
<p>14&nbsp;&nbsp;&nbsp; READ(tag, k)</p>
<p>15&nbsp;&nbsp;&nbsp; if k &lt; myid</p>
<p>16&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; WRITE(tag, myid)</p>
<p>17&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; goto Force</p>
<p>18&nbsp;&nbsp;&nbsp; if k &gt; myid</p>
<p>19&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; WAIT(UnlockTimeout)</p>
<p>20&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; READ(lock, lk)</p>
<p>21&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if lk == oldlock</p>
<p>22&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; WRITE(tag, 0)</p>
<p>23&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; goto Force</p>
<p>24&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; else</p>
<p>25&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; goto Lock</p>
<p>26&nbsp;&nbsp;&nbsp; if k == myid</p>
<p>27&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; WRITE(lock, oldlock)</p>
<p>28&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; goto Lock&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</p>
<p>Crit:</p>
<p>29&nbsp;&nbsp;&nbsp; CRITICAL_SECTION</p>
<p>Release:</p>
<p>30&nbsp;&nbsp;&nbsp; WRITE(lock, mylock)</p>
<p>Noncrit:&nbsp;&nbsp;&nbsp;</p>
<p>31&nbsp;&nbsp;&nbsp; NONCRITICAL_SECTION</p>
<p>32&nbsp;&nbsp;&nbsp; oldlock = -1</p>
<p>33&nbsp;&nbsp;&nbsp; goto Lock</p>
<p>Функция NewMylock() при каждом вызове возвращает целое значение, отличное от текущего содержимого регистра блокировки, а также от значений переменных mylock и oldlock на всех остальных ОУ. Размер регистра блокировки должен быть достаточным для хранения любого такого значения.</p>
<p>Попытка получения доступа к коммутатору (блокировки или захвата коммутатора) выражается в том, что ОУ на шаге 2 пытается записать в регистр блокировки значение mylock, после чего на шаге 3 читает фактическое значение регистра. Если было прочитано значение, равное mylock, то блокировка успешно получена и ОУ может переходить к выполнению критической секции. Сня- тие блокировки производится повторной записью  mylock в регистр (шаг 30), что возвращает его в исходное состояние.</p>
<p>Невыполнение устройством ожидаемого действия в течение определенного срока позволяет утверждать, что устройство вышло из строя [4].  В данном случае в силу предположения 1 таким действием является сброс регистра блокировки. По истечении срока регистр блокировки должен быть сброшен, чтобы система могла продолжить работу. На шагах 3&ndash;4 ОУ обнаруживает, что запомненное в переменной oldlock на шаге 10 значение все еще содержится в регистре блокировки по истечении срока ReleaseTimeout, следовательно, блокирующее коммутатор ОУ вышло из строя и необходимо принудительно сбросить установленную им блокировку. Однако если четное количество устройств попытается сбросить содержимое регистра, это приведет к тому, что в нем будет восстановлено прежнее значение. Следовательно, необходим механизм координации действий ОУ, пытающихся сбросить регистр.</p>
<p>Шаги 14&ndash;28 реализуют механизм определения ОУ с наибольшим идентификатором с использованием регистра метки. Этому ОУ предоставляется возможность окончательно сбросить регистр блокировки на шаге 27, в то время как остальные ОУ не смогут ему помешать, находясь в состоянии ожидания на шаге 19. Величина UnlockTimeout выбирается таким образом, чтобы превышать максимально возможное время записи нового значения в регистр блокировки устройством с максимальным идентификатором. Если ОУ выходит из состояния ожидания на шаге 19 и обнаруживает, что регистр блокировки содержит старое значение, значит, ОУ с максимальным идентификатором вышло из строя и необходимо начать процесс с начала.</p>
<p>Доказательство корректности алгоритма. Определим согласно [5] конфигурацию системы <img src="uploaded/image/2010-4/image041.gif" border="0" alt="" width="8" height="16" />&nbsp;как совокупность значений регистров коммутатора, множества отправленных, но еще не доставленных сообщений и состояний всех ОУ. Выполнением системы <img src="uploaded/image/2010-4/image043.gif" border="0" alt="" width="86" height="16" />&nbsp;назовем последовательность сменяющих друг друга конфигураций системы, не противоречащую алгоритму, выполняемому устройствами. В данной работе более строгое определение конфигурации и выполнения системы не требуется; важно лишь то, что в ходе выполнения системы, при котором каждое ОУ следует описанному алгоритму, на коммутаторе происходят события &ndash; атомарные действия по записи или чтению регистра метки или регистра блокировки. Обозначим пятеркой <img src="uploaded/image/2010-4/image045.gif" border="0" alt="" width="65" height="16" />&nbsp;событие, произошедшее на коммутаторе при выполнении системы <img src="uploaded/image/2010-4/image047.gif" border="0" alt="" width="8" height="16" />&nbsp;в момент <img src="uploaded/image/2010-4/image049.gif" border="0" alt="" width="5" height="16" />&nbsp;в результате отправки <img src="uploaded/image/2010-4/image051.gif" border="0" alt="" width="4" height="16" />-м устройством запроса на шаге <img src="uploaded/image/2010-4/image053.gif" border="0" alt="" width="8" height="16" />&nbsp;алгоритма, где вместо <img src="uploaded/image/2010-4/image055.gif" border="0" alt="" width="8" height="16" />&nbsp;в зависимости от регистра и выполняемого действия указывается: <img src="uploaded/image/2010-4/image057.gif" border="0" alt="" width="18" height="16" />&nbsp;&ndash; запись в регистр метки; <img src="uploaded/image/2010-4/image059.gif" border="0" alt="" width="14" height="16" />&nbsp;&ndash; чтение из регистра метки; <img src="uploaded/image/2010-4/image061.gif" border="0" alt="" width="17" height="16" />&nbsp;&ndash; запись в регистр блокировки; <img src="uploaded/image/2010-4/image063.gif" border="0" alt="" width="13" height="16" />&nbsp;&ndash; чтение из регистра блокировки. Множество событий, отличающихся только значением <img src="uploaded/image/2010-4/image065.gif" border="0" alt="" width="5" height="16" />&nbsp;и имеющих одинаковые <img src="uploaded/image/2010-4/image067.gif" border="0" alt="" width="8" height="16" />, <img src="uploaded/image/2010-4/image069.gif" border="0" alt="" width="4" height="16" />, <img src="uploaded/image/2010-4/image053.gif" border="0" alt="" width="8" height="16" />&nbsp;и <img src="uploaded/image/2010-4/image047.gif" border="0" alt="" width="8" height="16" />, определим как <img src="uploaded/image/2010-4/image071.gif" border="0" alt="" width="62" height="16" />. Обозначим <img src="uploaded/image/2010-4/image073.gif" border="0" alt="" width="33" height="16" />&nbsp;тот факт, что в некотором выполнении <img src="uploaded/image/2010-4/image075.gif" border="0" alt="" width="8" height="16" />&nbsp;событие <img src="uploaded/image/2010-4/image077.gif" border="0" alt="" width="7" height="16" />&nbsp;произошло на коммутаторе до события <img src="uploaded/image/2010-4/image079.gif" border="0" alt="" width="8" height="16" />&nbsp;(то есть <img src="uploaded/image/2010-4/image081.gif" border="0" alt="" width="70" height="16" />&nbsp;и <img src="uploaded/image/2010-4/image083.gif" border="0" alt="" width="39" height="16" />).</p>
<p>Последовательность событий, происходящих на коммутаторе при данном выполнении системы, или просто последовательность, &ndash; это множество событий, вполне упорядоченное по отношению <img src="uploaded/image/2010-4/image085.gif" border="0" alt="" width="10" height="16" />. Обозначим <img src="uploaded/image/2010-4/image087.gif" border="0" alt="" width="27" height="16" />&nbsp;последовательность, включающую все события, произошедшие на коммутаторе при выполнении системы <img src="uploaded/image/2010-4/image075.gif" border="0" alt="" width="8" height="16" />. Последовательность <img src="uploaded/image/2010-4/image089.gif" border="0" alt="" width="9" height="16" />&nbsp;называется допустимой, если возможно такое выполнение <img src="uploaded/image/2010-4/image047.gif" border="0" alt="" width="8" height="16" />, что <img src="uploaded/image/2010-4/image091.gif" border="0" alt="" width="53" height="16" />. Иными словами,  допустимая последовательность не противоречит алгоритму. Допустимую последовательность <img src="uploaded/image/2010-4/image089.gif" border="0" alt="" width="9" height="16" />&nbsp; будем называть полной, если для любых <img src="uploaded/image/2010-4/image093.gif" border="0" alt="" width="46" height="16" />&nbsp;не существует такой допустимой последовательности <img src="uploaded/image/2010-4/image095.gif" border="0" alt="" width="9" height="16" />, что <img src="uploaded/image/2010-4/image097.gif" border="0" alt="" width="48" height="16" />&nbsp;и <img src="uploaded/image/2010-4/image099.gif" border="0" alt="" width="107" height="16" />. Это означает, что для некоторых двух событий полная последовательность включает все события, происходящие между ними. Последовательностью без обнуления метки будем называть такую допустимую последовательность <img src="uploaded/image/2010-4/image089.gif" border="0" alt="" width="9" height="16" />&nbsp;для выполнения системы <img src="uploaded/image/2010-4/image047.gif" border="0" alt="" width="8" height="16" />, что найдется полная последовательность <img src="uploaded/image/2010-4/image101.gif" border="0" alt="" width="36" height="16" />, не содержащая событий из множеств <img src="uploaded/image/2010-4/image103.gif" border="0" alt="" width="79" height="16" />&nbsp;и <img src="uploaded/image/2010-4/image105.gif" border="0" alt="" width="79" height="16" />&nbsp;для любых <img src="uploaded/image/2010-4/image051.gif" border="0" alt="" width="4" height="16" />.</p>
<p>В некотором выполнении <img src="uploaded/image/2010-4/image047.gif" border="0" alt="" width="8" height="16" />&nbsp;для некоторого <img src="uploaded/image/2010-4/image051.gif" border="0" alt="" width="4" height="16" />&nbsp;события <img src="uploaded/image/2010-4/image107.gif" border="0" alt="" width="97" height="16" />&nbsp;и <img src="uploaded/image/2010-4/image109.gif" border="0" alt="" width="106" height="16" />&nbsp;будем называть парными, если <img src="uploaded/image/2010-4/image111.gif" border="0" alt="" width="34" height="16" />&nbsp;и между <img src="uploaded/image/2010-4/image113.gif" border="0" alt="" width="6" height="16" />&nbsp;и <img src="uploaded/image/2010-4/image115.gif" border="0" alt="" width="10" height="16" />&nbsp;нет других событий из множеств <img src="uploaded/image/2010-4/image117.gif" border="0" alt="" width="75" height="16" />&nbsp;и <img src="uploaded/image/2010-4/image119.gif" border="0" alt="" width="79" height="16" />.</p>
<p>Из алгоритма и предположения 3 можно непосредственно получить следующие свойства парных событий.</p>
<p>1.&nbsp;&nbsp; Для любого события <img src="uploaded/image/2010-4/image109.gif" border="0" alt="" width="106" height="16" />&nbsp;существует парное ему событие <img src="uploaded/image/2010-4/image107.gif" border="0" alt="" width="97" height="16" />.</p>
<p>2.&nbsp;&nbsp; В результате события <img src="uploaded/image/2010-4/image107.gif" border="0" alt="" width="97" height="16" />, парного некоторому событию записи, было прочитано значение <img src="uploaded/image/2010-4/image121.gif" border="0" alt="" width="30" height="16" />.</p>
<p>Теорема 1. В любом выполнении системы никакие два ОУ не могут выполнять критическую секцию одновременно.</p>
<p>Доказательство. Допустим, при выполнении системы <img src="uploaded/image/2010-4/image047.gif" border="0" alt="" width="8" height="16" />&nbsp;в некоторый момент существуют два ОУ &ndash; <img src="uploaded/image/2010-4/image051.gif" border="0" alt="" width="4" height="16" />&nbsp;и <img src="uploaded/image/2010-4/image123.gif" border="0" alt="" width="4" height="16" />, которые одновременно выполняют КС. Так как в КС можно попасть, только выполнив шаг 7, то на шаге 6 каждое из этих ОУ убедилось, что значение, прочитанное из регистра блокировки на шаге 3, совпадает со значением локальной переменной mylock, попытка записи которого в регистр блокировки была предпринята на шаге 2. Следовательно, эти попытки записи со стороны <img src="uploaded/image/2010-4/image051.gif" border="0" alt="" width="4" height="16" />&nbsp;и <img src="uploaded/image/2010-4/image123.gif" border="0" alt="" width="4" height="16" />&nbsp;оказались успешными. Попытка записи в регистр блокировки является успешной только тогда, когда регистр находится в сброшенном состоянии. Пусть ОУ <img src="uploaded/image/2010-4/image051.gif" border="0" alt="" width="4" height="16" />&nbsp;первым осуществило запись в регистр. Тогда имела место следующая последовательность событий:</p>
<p>1)&nbsp; <img src="uploaded/image/2010-4/image125.gif" border="0" alt="" width="105" height="16" />;</p>
<p>2)&nbsp; <img src="uploaded/image/2010-4/image127.gif" border="0" alt="" width="97" height="16" />;</p>
<p>3)&nbsp; событие, сбрасывающее регистр блокировки;</p>
<p>4)&nbsp; <img src="uploaded/image/2010-4/image129.gif" border="0" alt="" width="105" height="17" />;</p>
<p>5)&nbsp; <img src="uploaded/image/2010-4/image131.gif" border="0" alt="" width="96" height="17" />.</p>
<p>Третье событие может принадлежать или мно&shy;жеству <img src="uploaded/image/2010-4/image133.gif" border="0" alt="" width="78" height="16" />, или <img src="uploaded/image/2010-4/image135.gif" border="0" alt="" width="122" height="16" />.  В первом случае <img src="uploaded/image/2010-4/image051.gif" border="0" alt="" width="4" height="16" />&nbsp;завершает выполнение критической секции до того, как <img src="uploaded/image/2010-4/image123.gif" border="0" alt="" width="4" height="16" />&nbsp;начнет ее выполнение. Во втором случае сброс может произойти только в том случае, если устройство <img src="uploaded/image/2010-4/image051.gif" border="0" alt="" width="4" height="16" />&nbsp;удерживает блокировку в течение времени, превышающего ReleaseTimeout (шаг 11).</p>
<p>Учитывая предположение 1 об ограниченности времени выполнения критической секции, а также то, что между успешной записью в регистр блокировки в результате выполнения шага 2 и переходом к критической секции на шаге 15 устройство выполняет фиксированное число шагов (каждый из которых по предположению 4 выполняется за ограниченное время), можно выбрать значение ReleaseTimeout, превышающее максимальное время, которое может пройти с момента успешной записи в регистр блокировки до момента сброса регистра одним ОУ. В таком случае принудительный сброс блокировки будет выполняться только при выходе устройства из строя.</p>
<p>Так как выход устройства <img src="uploaded/image/2010-4/image051.gif" border="0" alt="" width="4" height="16" />&nbsp;из строя ведет к прекращению им выполнения критической секции, то и в этом случае <img src="uploaded/image/2010-4/image051.gif" border="0" alt="" width="4" height="16" />&nbsp;не может выполнять критическую секцию одновременно с <img src="uploaded/image/2010-4/image123.gif" border="0" alt="" width="4" height="16" />. Исходное допущение оказалось неверным, что и доказывает справедливость теоремы.</p>
<p>Лемма 1. Для любого выполнения системы <img src="uploaded/image/2010-4/image047.gif" border="0" alt="" width="8" height="16" />&nbsp; в любой полной последовательности без обнуления метки <img src="uploaded/image/2010-4/image091.gif" border="0" alt="" width="53" height="16" />&nbsp;между двумя событиями из множества <img src="uploaded/image/2010-4/image119.gif" border="0" alt="" width="79" height="16" />&nbsp;найдется событие  из множества <img src="uploaded/image/2010-4/image137.gif" border="0" alt="" width="122" height="16" />.</p>
<p>Доказательство. Предположим, что для некоторого <img src="uploaded/image/2010-4/image051.gif" border="0" alt="" width="4" height="16" />&nbsp;в <img src="uploaded/image/2010-4/image089.gif" border="0" alt="" width="9" height="16" />&nbsp;входят два события записи <img src="uploaded/image/2010-4/image139.gif" border="0" alt="" width="50" height="16" /> <img src="uploaded/image/2010-4/image141.gif" border="0" alt="" width="153" height="16" />, и не существует со- бытия записи <img src="uploaded/image/2010-4/image143.gif" border="0" alt="" width="199" height="16" /> <img src="uploaded/image/2010-4/image145.gif" border="0" alt="" width="67" height="16" />, то есть между двумя записями в регистр метки со стороны устройства <img src="uploaded/image/2010-4/image051.gif" border="0" alt="" width="4" height="16" />&nbsp;нет записей со стороны других устройств.</p>
<p>По свойству 1 парных событий для этих двух событий записи существуют парные им события чтения <img src="uploaded/image/2010-4/image147.gif" border="0" alt="" width="119" height="16" />.</p>
<p>Из условия леммы и определения парных событий следует, что существует такая полная последовательность <img src="uploaded/image/2010-4/image149.gif" border="0" alt="" width="13" height="16" />, в которую входят события <img src="uploaded/image/2010-4/image151.gif" border="0" alt="" width="16" height="16" />, <img src="uploaded/image/2010-4/image153.gif" border="0" alt="" width="16" height="16" />, <img src="uploaded/image/2010-4/image155.gif" border="0" alt="" width="11" height="16" />&nbsp;и <img src="uploaded/image/2010-4/image157.gif" border="0" alt="" width="11" height="16" />. Из исходного предположения и свойства 2 парных событий следует, что для <img src="uploaded/image/2010-4/image157.gif" border="0" alt="" width="11" height="16" />, парного <img src="uploaded/image/2010-4/image159.gif" border="0" alt="" width="16" height="16" />, не может выполняться <img src="uploaded/image/2010-4/image161.gif" border="0" alt="" width="79" height="16" />, следовательно, верно <img src="uploaded/image/2010-4/image163.gif" border="0" alt="" width="107" height="16" />&nbsp;или <img src="uploaded/image/2010-4/image165.gif" border="0" alt="" width="107" height="16" />, что противоречит определению парных событий. Таким образом, исходное предположение оказалось неверным, следовательно, лемма верна.</p>
<p>Лемма 2. Для любого выполнения системы <img src="uploaded/image/2010-4/image047.gif" border="0" alt="" width="8" height="16" />&nbsp;любая полная последовательность без обнуления метки <img src="uploaded/image/2010-4/image091.gif" border="0" alt="" width="53" height="16" />&nbsp;может включать не более <img src="uploaded/image/2010-4/image167.gif" border="0" alt="" width="103" height="16" />&nbsp;событий записи в регистр метки, где <img src="uploaded/image/2010-4/image169.gif" border="0" alt="" width="9" height="16" />&nbsp;&ndash; количество ОУ в системе.</p>
<p>Доказательство. Для случая <img src="uploaded/image/2010-4/image171.gif" border="0" alt="" width="35" height="16" />&nbsp;лемма выполняется тривиально. Докажем ее истинность для всех <img src="uploaded/image/2010-4/image169.gif" border="0" alt="" width="9" height="16" />&nbsp;по индукции. Предположим, что лемма выполняется для случая <img src="uploaded/image/2010-4/image173.gif" border="0" alt="" width="35" height="16" />, и покажем, что в этом случае она верна и для <img src="uploaded/image/2010-4/image175.gif" border="0" alt="" width="59" height="16" />.</p>
<p>Пусть <img src="uploaded/image/2010-4/image177.gif" border="0" alt="" width="7" height="16" />&nbsp;&ndash; наименьший идентификатор среди всех <img src="uploaded/image/2010-4/image179.gif" border="0" alt="" width="32" height="16" />&nbsp;устройств. Из алгоритма следует, что в любой полной последовательности без обнуления метки событие <img src="uploaded/image/2010-4/image181.gif" border="0" alt="" width="114" height="17" />&nbsp;может быть только одно. Оно разделяет последовательность на две подпоследовательности, в каждой из которых, по предположению индукции, может быть не более <img src="uploaded/image/2010-4/image183.gif" border="0" alt="" width="38" height="16" />&nbsp;событий записи в регистр метки со стороны <img src="uploaded/image/2010-4/image053.gif" border="0" alt="" width="8" height="16" />&nbsp;оставшихся устройств. Следовательно, вся последовательность может содержать не более <img src="uploaded/image/2010-4/image185.gif" border="0" alt="" width="150" height="18" />&nbsp;событий записи в регистр метки. Таким образом, для <img src="uploaded/image/2010-4/image169.gif" border="0" alt="" width="9" height="16" />&nbsp;устройств любая полная последовательность без обнуления метки содержит не более <img src="uploaded/image/2010-4/image167.gif" border="0" alt="" width="103" height="16" />&nbsp;событий записи в регистр метки. Что и требовалось доказать.</p>
<p>Лемма 3. Для любого выполнения системы <img src="uploaded/image/2010-4/image047.gif" border="0" alt="" width="8" height="16" />&nbsp;любая полная последовательность без обнуления метки <img src="uploaded/image/2010-4/image091.gif" border="0" alt="" width="53" height="16" />&nbsp;может включать не более <img src="uploaded/image/2010-4/image187.gif" border="0" alt="" width="122" height="16" />&nbsp;событий из <img src="uploaded/image/2010-4/image189.gif" border="0" alt="" width="107" height="16" />, где <img src="uploaded/image/2010-4/image169.gif" border="0" alt="" width="9" height="16" />&nbsp;&ndash; количество ОУ в системе.</p>
<p>Доказательство. Из леммы 2 следует, что количество событий записи в регистр метки в любой полной последовательности без обнуления метки <img src="uploaded/image/2010-4/image089.gif" border="0" alt="" width="9" height="16" />&nbsp;не может превышать <img src="uploaded/image/2010-4/image191.gif" border="0" alt="" width="39" height="16" />, что дает <img src="uploaded/image/2010-4/image193.gif" border="0" alt="" width="68" height="16" />&nbsp;интервалов времени, в каждом из которых регистр метки содержит идентификатор одного из ОУ. Рассмотрим интервал, ограничиваемый событиями <img src="uploaded/image/2010-4/image195.gif" border="0" alt="" width="109" height="16" />&nbsp;и <img src="uploaded/image/2010-4/image197.gif" border="0" alt="" width="109" height="17" />, причем, согласно лемме 1, <img src="uploaded/image/2010-4/image199.gif" border="0" alt="" width="26" height="16" />. На протяжении всего этого интервала в регистре метки содержится <img src="uploaded/image/2010-4/image051.gif" border="0" alt="" width="4" height="16" />.</p>
<p>Если после выполнения устройством <img src="uploaded/image/2010-4/image051.gif" border="0" alt="" width="4" height="16" />&nbsp;шага 27 регистр блокировки был сброшен, то при следующем выполнении шага 2 коммутатор будет захвачен этим устройством. Но если между выполнением шагов 27 и 2 устройством <img src="uploaded/image/2010-4/image051.gif" border="0" alt="" width="4" height="16" />&nbsp;произойдет событие записи со стороны устройства <img src="uploaded/image/2010-4/image201.gif" border="0" alt="" width="30" height="16" />, то в регистре блокировки будет восстановлено прежнее значение и устройство <img src="uploaded/image/2010-4/image051.gif" border="0" alt="" width="4" height="16" />&nbsp;сможет выполнить шаг 27 еще один раз в интервале <img src="uploaded/image/2010-4/image053.gif" border="0" alt="" width="8" height="16" />. Это возможно только в том случае, если устройство <img src="uploaded/image/2010-4/image203.gif" border="0" alt="" width="8" height="16" />&nbsp;выполнило шаги 14 и 26 в интервале <img src="uploaded/image/2010-4/image205.gif" border="0" alt="" width="38" height="16" />, а выполнение шага 27 отложило до интервала <img src="uploaded/image/2010-4/image053.gif" border="0" alt="" width="8" height="16" />. Если в интервале <img src="uploaded/image/2010-4/image053.gif" border="0" alt="" width="8" height="16" />&nbsp;произошло <img src="uploaded/image/2010-4/image207.gif" border="0" alt="" width="16" height="16" />&nbsp;таких отложенных событий записи, устройство <img src="uploaded/image/2010-4/image051.gif" border="0" alt="" width="4" height="16" />&nbsp;сможет выполнить шаг 27 еще не более <img src="uploaded/image/2010-4/image207.gif" border="0" alt="" width="16" height="16" />&nbsp;раз.</p>
<p>Рассмотрим возможные состояния регистра блокировки в начале интервала <img src="uploaded/image/2010-4/image053.gif" border="0" alt="" width="8" height="16" />.</p>
<p>1.&nbsp;&nbsp; Регистр блокировки содержит идентификатор вышедшего из строя устройства. Тогда устройство <img src="uploaded/image/2010-4/image051.gif" border="0" alt="" width="4" height="16" />&nbsp;сбросит регистр блокировки при первом выполнении шага 27.</p>
<p>2.&nbsp;&nbsp; Регистр блокировки сброшен. Тогда устройство <img src="uploaded/image/2010-4/image051.gif" border="0" alt="" width="4" height="16" />&nbsp;сбросит регистр блокировки при втором выполнении шага 27.</p>
<p>В первом случае в интервале <img src="uploaded/image/2010-4/image053.gif" border="0" alt="" width="8" height="16" />&nbsp;может произойти не более <img src="uploaded/image/2010-4/image209.gif" border="0" alt="" width="48" height="16" />&nbsp;событий из <img src="uploaded/image/2010-4/image211.gif" border="0" alt="" width="107" height="16" />, и при выполнении в интервале <img src="uploaded/image/2010-4/image213.gif" border="0" alt="" width="7" height="16" />&nbsp;такого числа событий к началу интервала <img src="uploaded/image/2010-4/image179.gif" border="0" alt="" width="32" height="16" />&nbsp;регистр блокировки будет сброшен. Во втором случае в интервале <img src="uploaded/image/2010-4/image053.gif" border="0" alt="" width="8" height="16" />&nbsp;может произойти не более <img src="uploaded/image/2010-4/image215.gif" border="0" alt="" width="48" height="16" />&nbsp;таких событий, и при этом в начале интервала <img src="uploaded/image/2010-4/image179.gif" border="0" alt="" width="32" height="16" />&nbsp;регистр также будет сброшен. Таким образом, в случае выполнения максимального количества событий записи в интервале <img src="uploaded/image/2010-4/image053.gif" border="0" alt="" width="8" height="16" />&nbsp;в интервале <img src="uploaded/image/2010-4/image179.gif" border="0" alt="" width="32" height="16" />&nbsp;может быть выполнено не более <img src="uploaded/image/2010-4/image217.gif" border="0" alt="" width="60" height="16" />&nbsp;событий записи в регистр блокировки. Если же одно событие записи, которое могло произойти в интервале <img src="uploaded/image/2010-4/image053.gif" border="0" alt="" width="8" height="16" />, было отложено, то в интервале <img src="uploaded/image/2010-4/image179.gif" border="0" alt="" width="32" height="16" />&nbsp;может быть выполнено не более <img src="uploaded/image/2010-4/image219.gif" border="0" alt="" width="60" height="16" />&nbsp;событий. Следовательно, откладывание одного события из интервала <img src="uploaded/image/2010-4/image053.gif" border="0" alt="" width="8" height="16" />&nbsp;уменьшает максимальное число событий в интервале <img src="uploaded/image/2010-4/image179.gif" border="0" alt="" width="32" height="16" />&nbsp;на 1.</p>
<p>Очевидно, что в каждом интервале может быть отложено не более одного события, и из последнего интервала отложить событие нельзя. Пусть на протяжении всей последовательности было отложено <img src="uploaded/image/2010-4/image221.gif" border="0" alt="" width="39" height="16" />&nbsp;событий. Тогда общее количество событий из <img src="uploaded/image/2010-4/image223.gif" border="0" alt="" width="94" height="16" />&nbsp;во всей  последовательности составит <img src="uploaded/image/2010-4/image225.gif" border="0" alt="" width="91" height="16" /> <img src="uploaded/image/2010-4/image227.gif" border="0" alt="" width="605" height="35" />максимальное число событий в первом интервале. В зависимости от изначального состояния регистра блокировки оно может составлять 1 или 2. Следовательно, можно утверждать, что <img src="uploaded/image/2010-4/image229.gif" border="0" alt="" width="162" height="16" /></p>
<p>Таким образом, лемма верна.</p>
<p>Теорема 2. Если в некоторый момент хотя бы одно из <img src="uploaded/image/2010-4/image231.gif" border="0" alt="" width="9" height="16" />&nbsp;работоспособных в системе ОУ желает выполнить КС (вошло в состояние Lock), то через ограниченное сверху количество обращений к регистрам метки и блокировки коммутатор будет захвачен одним из ОУ.</p>
<p>Доказательство. Справедливость теоремы очевидна, если на момент выполнения шага 2 первым из устройств, желающих выполнить КС,  регистр блокировки был сброшен. В этом случае захват будет произведен за одно обращение.</p>
<p>Если же коммутатор был захвачен другим устройством, которое в ходе выполнения КС не выходит из строя и сбрасывает регистр блокировки на шаге 30, то все устройства, вошедшие в состояние Lock в то время, когда коммутатор был захвачен, можно разделить на две группы:</p>
<p>&middot;&nbsp;&nbsp;&nbsp;&nbsp; устройства, которые успели выполнить шаг 2 до сброса регистра;</p>
<p>&middot;&nbsp;&nbsp;&nbsp;&nbsp; устройства, которые выполнили шаг 2 после сброса регистра.</p>
<p>Значит, если во второй группе есть хотя бы одно устройство, первое из них, которое выполнит шаг 2, захватит коммутатор. Устройству из первой группы для захвата необходимо выполнить два обращения к регистрам, если на шаге 2 было прочитано значение EMPTY. В противном случае устройству придется выполнить третье обращение &ndash; на шагах 3, 12 и 2, так как, по предположению 1, сброс произойдет до выполнения любым из устройств шага 12. Таким образом, количество обращений к регистрам будет максимальным, когда все устройства входят в первую группу. После того как каждое устройство выполнит шаги 3 и 12, первое же выполнение любым из них шага 2 приведет к захвату. Таким образом, для захвата коммутатора потребуется не более <img src="uploaded/image/2010-4/image233.gif" border="0" alt="" width="76" height="16" />&nbsp;обращений к регистрам.</p>
<p>Рассмотрим случай, когда коммутатор был захвачен и захватившее его устройство вышло из строя, не сбросив регистр блокировки. Из алгоритма видно, что обнуление регистра метки на шаге 12 может быть выполнено каждым устройством только один раз на каждую попытку захвата коммутатора. К обнулению метки приводит также выполнение шага 22. Этот шаг может быть выполнен каждым устройством один раз на каждый выход из строя ОУ с наибольшим идентификатором. Поскольку выход ОУ из строя уменьшает общее число устройств на 1, то шаги 20 и 22 могут быть выполнены не более <img src="uploaded/image/2010-4/image235.gif" border="0" alt="" width="30" height="16" />&nbsp;раз до следующего захвата коммутатора. Таким образом, с момента вхождения первого ОУ в состояние Lock до следующего захвата коммутатора может быть выполнено не более <img src="uploaded/image/2010-4/image237.gif" border="0" alt="" width="91" height="16" />&nbsp;обнулений регистра метки.</p>
<p>Из леммы 2 следует, что до следующего захвата коммутатора может быть выполнено не более <img src="uploaded/image/2010-4/image239.gif" border="0" alt="" width="104" height="16" />&nbsp;записей в регистр метки на ша- ге 16, а из леммы 3 &ndash; не более <img src="uploaded/image/2010-4/image241.gif" border="0" alt="" width="111" height="16" />&nbsp;записей в регистр блокировки на шаге 27. Последнее означает, что до следующего захвата блоки- ровки может существовать не более <img src="uploaded/image/2010-4/image243.gif" border="0" alt="" width="32" height="16" /> <img src="uploaded/image/2010-4/image245.gif" border="0" alt="" width="81" height="16" />&nbsp;интервалов времени, в которых регистр блокировки сброшен. Из алгоритма следует, что каждое устройство может выполнить цикл шагов 2&ndash;3&ndash;8&ndash;9 не более одного раза в каждом таком интервале.</p>
<p>Заметим, что каждая запись в регистр метки на шаге 16 требует чтения на шаге 14, каждая запись в регистр блокировки на шаге 27 &ndash; чтения на шаге 14, каждое обнуление регистра метки требует только одного обращения к регистру, каждый цикл 2&ndash;3&ndash;8&ndash;9 включает в себя два обращения &ndash; на шагах 2 и 3, а каждому выполнению шага 20 предшествует выполнение шага 14.</p>
<p>Из алгоритма видно, что никакие другие шаги устройствами не выполняются. Следовательно, верхняя граница количества обращений к регистрам метки и блокировки составляет</p>
<p><img src="uploaded/image/2010-4/image247.gif" border="0" alt="" width="277" height="32" /> <img src="uploaded/image/2010-4/image249.gif" border="0" alt="" width="236" height="26" />.</p>
<p>Как можно видеть, максимальное количество обращений ограниченно и зависит от <img src="uploaded/image/2010-4/image169.gif" border="0" alt="" width="9" height="16" />. Теорема верна.</p>
<p>Следует обратить внимание на то, что предположение 2 не допускает возможности наличия такого распространенного вида отказов, как перезагрузка. Если каждое устройство перезагружается, обладая наибольшим идентификатором среди устройств, участвующих в принудительном сбросе блокировки, а после перезагрузки сразу пытается захватить коммутатор, то возможна последовательность событий, приводящая к тому, что выполнение критической секции будет бесконечно откладываться. Однако попытка захвата после перезагрузки отличается от попытки захвата, предпринимаемой тем же устройством до момента перезагрузки, в том смысле, что отличаются соответствующие значения mylock. Перезагрузку тогда можно представить как отключение устройства от системы с последующим подключением нового устройства; при этом N увеличивается на 1. Если перезагрузки происходят бесконечно, бесконечными будут и величина <img src="uploaded/image/2010-4/image169.gif" border="0" alt="" width="9" height="16" />, и значение функции <img src="uploaded/image/2010-4/image251.gif" border="0" alt="" width="51" height="16" />, что согласуется с теоремой 2.</p>
<p>Рассмотрим подробнее значение, возвращаемое функцией NewMylock(). Если после перезагрузки значение mylock не изменилось, по ее окончании ОУ может вмешаться в процесс снятия собственной блокировки. Нетрудно показать, что  в результате процесс сброса регистра блокировки может стать бесконечным. Также возможен сценарий, приводящий к ложному обнаружению отказа, как, например, следующая последовательность действий: устройство 1 захватывает коммутатор, устройство 2 после неудачной попытки захвата переходит в состояние ожидания, устройство 1 освобождает коммутатор, устройство 1 захватывает коммутатор, устройство 2 выходит из сос- тояния ожидания. Здесь устройство 2 будет считать, что устройство 1 вышло из строя, хотя это  не так.</p>
<p>Таким образом, при каждой попытке блокировки необходимо изменять значения mylock, что и делается на шаге 0 алгоритма, причем после перезагрузки это значение должно отличаться от предыдущего, даже если перезагрузка произошла во время выполнения критической секции.</p>
<p>Один из возможных вариантов &ndash; составлять значение mylock из идентификатора ОУ и числа, значение которого увеличивается на 1 и записывается в постоянную память до того, как будет выполнена каждая попытка записи mylock с предыдущим значением числа в регистр блокировки. После перезагрузки устройство считывает это число из памяти, после чего значение mylock будет уже новым, что позволит избежать описанных выше проблем.</p>
<p>Алгоритм неявно предполагает, что размера регистра метки достаточно для записи в него идентификатора любого устройства, а размера регистра блокировки &ndash; для записи любого возможного значения mylock. В действительности, согласно стандарту RapidIO, размер регистра метки &ndash; 32 бита, а регистра блокировки &ndash; 16 бит. Это не позволяет строго реализовать функцию NewMylock(). Например, если 8 бит значения mylock содержат идентификатор устройства и еще 8 бит &ndash; описанное выше уникальное число, то количество ОУ в этом случае ограничивается 256, и если устройство перезагружается во время выполнения критической секции, до успешного сброса старой блокировки это устройство может перезагрузиться не более 256 раз, так как иначе значение mylock может совпасть с записанным в регистре блокировки.</p>
<p>С помощью разработанного алгоритма решается проблема предоставления исключительного доступа к коммутатору RapidIO в случае возможного отказа оконечного устройства в любой момент его работы. Достоинствами алгоритма являются конечность времени принятия решения о предоставлении доступа к коммутатору и фиксированное количество действий в отсутствие конкуренции за доступ. Алгоритм не делает никаких предположений об относительной скорости выполнения программ оконечными устройствами, а также о постоянстве этих скоростей.</p>
<p>Литература  &nbsp;</p>
<p>1.&nbsp;&nbsp; Бакулин А.А. Взаимодействие компонентов высокопроизводительных параллельных систем с помощью технологии RapidIO // Моделирование и визуализация. Многопроцессорные системы. Инструментальные средства разработки ПО. [под ред. В.Б. Бетелина]. М.: НИИСИ РАН, 2009. С. 77&ndash;89.</p>
<p>2.&nbsp;&nbsp; RapidIO Interconnect Specification. Part 3: Common Transport Specification. Revision 1.3. RapidIO Trade Association, 2005. URL: http://www.rapidio.org/specs/disclaimer?specfile=/zda&shy;ta/specs/cmn_trnspt.pdf (дата обращения: 15.06.2010).</p>
<p>3.&nbsp;&nbsp; RapidIO Interconnect Specification. Part 4: Physical Layer 8-16 LP-LVDS Specification. Revision 1.3. RapidIO Trade Association, 2005. URL: http://www.rapidio.org/specs/disclai&shy;mer?specfile=/zdata/specs/parallel_phy.pdf (дата обращения: 15.06.2010).</p>
<p>4.&nbsp;&nbsp; Fischer M., Lynch N., Paterson M. Impossibility of Distributed Consensus with One Faulty Process // Journal of the ACM. 1985. Vol. 32. Is. 2, pp. 374&ndash;382.</p>
<p>5.&nbsp;&nbsp; Тель Ж. Введение в распределенные алгоритмы. М.: МЦМНО, 2009.</p></div><br /></td></tr></table><table border="0" width="100%" style="width:100%;">
                   <tr>
                      <td><b>Постоянный адрес статьи: http://swsys.ru/index.php?page=article&id=2606</b></td>
                      <td align="right"><a target="_blank" href="/print/article_print.php?id=2606">Версия для печати</a></td>
                   </tr>
                   <tr>
                      <td><b>Статья опубликована в выпуске журнала № 4 за 2010 год.</b></td>                      
                                  </tr>            <tr><td><a href="http://swsys.ru/pay/form.php?journal=92">Электронная подписка на данный выпуск в формате PDF</a>            </tr></td>              
          </table><br /><a href="javascript:history.back();">Назад, к списку статей</a><br /><br />Хотите оценить статью или опубликовать комментарий к ней - <a href="http://swsys.ru/index.php?page=registry">зарегистрируйтесь</a><br /><br />




				
				<div id="ie_clearing">&nbsp;</div>
				<!-- End: IE Column Clearing -->
				
			</div>
			<!-- end: #col3 -->
            
         
            
		</div>
        
		<!-- end: #main -->
		<!-- begin: #footer -->


         </div>


		<div id="footer">

			<div class="black">Журнал зарегистрирован в комитете РФ по печати</div><div style="margin:0px; padding:0px; line-height:16px">
			Свидетельство о регистрации средства массовой информации № 013831 от 26.11.99 г.<br />
			Решение Президиума Высшей аттестационной комиссии Министерства образования и науки РФ от 19.02.2010 г. (о внесении в Перечень ведущих рецензируемых научных журналов и изданий, в которых должны быть опубликованы основные научные результаты диссертаций на соискание ученых степеней кандидата и доктора наук).<br />
&copy; Все права на авторские материалы охраняются в соответствии с законодательством РФ. Перепечатка возможна только с разрешения редакции. При цитировании материалов обязательна ссылка на Международный журнал "Программные продукты и системы" (для on-line проектов обязательна гиперссылка).</div>
			

			<div style="margin-top:15px;float:left">
<!--LiveInternet counter--><script type="text/javascript"><!--
document.write("<a href='http://www.liveinternet.ru/click' "+
"target=_blank><img src='http://counter.yadro.ru/hit?t26.1;r"+
escape(document.referrer)+((typeof(screen)=="undefined")?"":
";s"+screen.width+"*"+screen.height+"*"+(screen.colorDepth?
screen.colorDepth:screen.pixelDepth))+";u"+escape(document.URL)+
";"+Math.random()+
"' alt='' title='LiveInternet: показано число посетителей за"+
" сегодня' "+
"border=0 width=88 height=15><\/a>")//--></script><!--/LiveInternet-->
			</div>

			<div align="right" style="margin:15px">
               <a target="_blank" href="http://www.cps.tver.ru">Сайт разработан в <span>НИИ &laquo;ЦЕНТРПРОГРАММСИСТЕМ&raquo;</span></a><br />
               <a href="http://swsys.ru/index.php?page=17">Информация о сайте</a>
            </div>

		</div>		
		<!-- end: #footer -->



	</div>

</div>



<style>

.reklama {
    color: #666;
   font-size:11px;
   font-family:Arial;
  padding-bottom:20px;
}
.reklama a {
    color: #666;
   text-decoration:underline;
}
.reklama a:hover {
    color: #000;
   text-decoration:none;
}
 

@media print {
  .reklama {
      display:none;
  }
}

</style>




</div>


 






<script type="text/javascript">
/*
var gaJsHost = (("https:" == document.location.protocol) ? "https://ssl." : "http://www.");
document.write(unescape("%3Cscript src='" + gaJsHost + "google-analytics.com/ga.js' type='text/javascript'%3E%3C/script%3E"));
*/
</script>
<script type="text/javascript">
/*
try {
var pageTracker = _gat._getTracker("UA-9821437-1");
pageTracker._trackPageview();
} catch(err) {}
*/
</script>

</body>
</html>
