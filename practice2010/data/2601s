<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
   "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="ru" lang="ru">
<head>
<meta http-equiv="Content-Type" content="text/html;charset=utf-8"/>

<meta name="sprypayUrlChecker" content="sprypay_fpraOIA7CnzFuVkwTFol4GEMpK3RdzExgx4SCKayofR7wwGQvRBfNE2QUww9JV84_1763">

<title>Параллельная генерация пространства состояний дискретных детерминированных моделей</title>     <style>
	 .sps {
        padding-left: 20px;
        line-height: 20px;
	   padding:1px;
	   margin:0px;
     }

     .hed {
       color: #666666;
       font: bold;
       font-size: 14px;
       border: 1px solid;
	   padding:1px;
	   margin:0px;
     }

     .trhed {
       padding: 25px;
     }
	 
	 .td_arch {
	   margin:0px;
	   padding:5px;
	  }
	 
	 .in_journal {
	  border:3px solid #fff;
	 }

	 .in_journal:hover {
	  border:3px solid #aaaaaa;
	 }
	 
     .ndisp {
         display:none;
     }
     
	  </style>

<!--[if IE]>
<style>
.outer, .wrapper, .minwidth {
	zoom: 1;
}

</style>
<![endif]-->

<!--[if lt IE 7]>
<style>
.minwidth {
	border-left: 504px solid #fff;
}
.wrapper {
	margin-left: -504px;
	position: relative;
}
</style>
<![endif]-->

<link href="css/layout_2col_right_31.css" rel="stylesheet" type="text/css"/>	  

<link href="style.css" type="text/css" rel="stylesheet" />
<link rel="alternate" type="application/rss+xml" title="RSS" href="http://www.swsys.ru/rss">

<!--[if lte IE 7]>
<link href="css/patches/patch_2col_right_31.css" rel="stylesheet" type="text/css" />
<![endif]-->

    <script src="script/CalendarPopup.js"></script>


<script>

function submit_login() {
 if ( document.login_form.login.value != "" && document.login_form.password.value != "" ) { 
  document.login_form.activity.value = "AUTORIZ";
  document.login_form.submit();
  }
 else 
 {
 alert("Введите логин и пароль"); 
 document.login_form.username.focus();
 }
 
}

 function to_registry() {
	document.login_form.action = "event.php?page=registry";
    document.login_form.submit();
 }

 function to_search() {
    document.search_form.submit();
 }

</script>

</head>
<body>








<div id="page_margins">
	<div id="page">
		<div id="header">
			<div id="topnav">
				  <form action="event.php?page=search&order=date"  method="post" id="search-theme-form" name="search_form">
<div><div id="search" class="container-inline"><div class="form-item">
 <input type="text" maxlength="128" name="search" id="edit-search-theme-form-keys"  size="15" value="поиск..." title="Введите слова для поиска." class="form-text" onBlur="if ( this.value == '' ) this.value = 'поиск...';" onFocus="if ( this.value=='поиск...' ) this.value='';"/>
 <a href="#" onclick="Javascript: if ( document.search_form.search.value == 'поиск...' ) { alert('Введите поисковый запрос!') } else document.search_form.submit()">Найти</a>
</div>
</div>
</div></form>
				<div id="subsearch"><span><a href="index.php?page=extsearch">Расширенный поиск</a> / <a href="index.php?page=sitemap">Карта сайта</a></span></div> </div>
			<span style="cursor:pointer" onclick="Javascript:document.location = 'index.php'" class="zag">Международный журнал</span>
			<h1 style="cursor:pointer; width:auto" onclick="Javascript:document.location = 'index.php'">Программные продукты и системы</h1>
		   
			</div>
		<!-- begin: main navigation #nav -->
		<div id="nav"> <a id="navigation" name="navigation"></a>
			<!-- skiplink anchor: navigation -->			
		</div>
		<!-- end: main navigation -->
		<!-- begin: main content area #main -->
		<div id="main">
			<!-- begin: #col1 - first float column -->
			<div id="col1">
				<div id="col1_content" class="clearfix">
					<div id="menu" class="r-block">
						<h2>Разделы сайта</h2>
						<ul id="submenu">
						
						<li style="white-space:nowrap;margin-left:-15px"><a href="index.php?page=1">О журнале</a></li><li style="white-space:nowrap;margin-left:-15px"><a href="index.php?page=3">Редколлегия</a></li><li style="white-space:nowrap;margin-left:-15px"><a href="index.php?page=12">Научные направления</a></li><li style="white-space:nowrap;margin-left:-15px"><a href="index.php?page=9">Свежий выпуск</a></li><li style="white-space:nowrap;margin-left:-15px"><a href="index.php?page=19">Список авторов выпуска</a></li><li style="white-space:nowrap;margin-left:-15px"><a href="index.php?page=10">Архив выпусков</a></li><li style="white-space:nowrap;margin-left:-15px"><a href="index.php?page=11">Подписка</a></li><li style="white-space:nowrap;margin-left:-15px"><a href="index.php?page=5">Авторам и издателям</a></li>						
					  </ul>	
					</div>	

     
					<div id="login" class="mainborder r-block">
                    
                    <h2>Вход</h2>				
				   <form action="event.php?page=article"  method="post" id="login-form" name="login_form">
<div id="login-form-div">
	<div class="form-item"><input type="text" maxlength="128" name="login" size="15" value="" title="" class="form-text" /></div>
 <div class="form-item"><input type="password" maxlength="128" name="password" size="15" value="" title="" class="form-text"/></div>
 <input type="hidden" name="activity" />
 
        <label for="save_pas"><input type="checkbox" style="width:25px;border:none;" name="save_pas" id="save_pas" />Запомнить</label><br />

  <div id="login-button"><input style="border:none;width:46px;height:45px" type="image" src="images/login-button1.gif" onclick="submit_login();"></div> 
<!-- <input type="submit" /> -->
</div></form>
				 
				<span><a href="index.php?page=recovery">Забыли пароль?</a> / <a href="#" onclick="to_registry();">Регистрация</a></span>				  
                         
                 

                 
                 
				  </div>


                  
                  

           
  
  <div style="padding: 5px 0px 0px 45px">     
<script type="text/javascript"><!--
google_ad_client = "pub-6573451237838679";
/* Вторая страница право */
google_ad_slot = "0208394776";
google_ad_width = 120;
google_ad_height = 240;
//-->
</script>
<script type="text/javascript"
src="http://pagead2.googlesyndication.com/pagead/show_ads.js">
</script>                  
     </div>
     
      
				  
				  
				                    <div id="next-after" class="r-block">
                    <h2>Добавить в закладки</h2>
                    <script src="/ok2.js" type="text/javascript"></script>
                  </div>
                  
				  <div id="next-after" class="r-block">
					<h2>Следующий номер</h2>
					<div id="sled-nomer" class="floatbox"><span class="simv-nomer">№</span>1</div>
					<div id="sled-nomer-text">
					Выходит:<br/>
					<div> 18 Марта 2011 </div>
                     				  </div>
				 </div>
				  <div class="r-block" id="arh">
					<h2>Выпуски</h2>

 						<div class="god">2010</div><ul><li><a href="index.php?page=search&order=date&journal=92">№4 Декабрь 2010</a></li><li><a href="index.php?page=search&order=date&journal=91">№3 Сентябрь 2010</a></li><li><a href="index.php?page=search&order=date&journal=90">№2 Май 2010</a></li><li><a href="index.php?page=search&order=date&journal=89">№1 Март 2010</a></li></ul>
				
						<div align="center" style="margin-top:0px; padding:0px" ><a style="font-size:12px" href="index.php?page=10">все выпуски</a></div>
						<div align="center" style="margin-top:0px; padding:0px" ><a style="font-size:12px" href="index.php?page=all_article">все статьи</a></div>
				  </div>
				  
				  
				</div>

                  <div id="next-after" class="r-block">
                    <h2>Новости</h2>  
                                 
                        <p>     
                        <a href="index.php?page=show_news&id=117">В Международном университете природы, общества и человека (г. Дубна) предложен алгоритм генерации растущих сетей с нелинейным предпочтительным присоединением, конкуренцией и удалением узлов</a> [15.12.2010]
                        <br/>
                                     
                        <p>     
                        <a href="index.php?page=show_news&id=116">В Группе компаний «Генезис знаний» (г. Самара) предложено решение по построению и внедрению мультиагентной системы распределения производственных ресурсов МАС «Оптимизатор»</a> [08.12.2010]
                        <br/>
                                     
                        <p>     
                        <a href="index.php?page=show_news&id=115">В Волгоградском государственном техническом университете разработана модель обучающей системы в области автомобильного транспорта</a> [01.12.2010]
                        <br/>
                                                
                        <div style="text-align:center"><a href="index.php?page=show_news">читать все новости</a></div>
                        
                                          </div>

					<div class="r-block" style="text-align:center;padding:0px;margin:0px;">
					   <a style="text-decoration:none;" href="rss/"><img alt="RSS" title="RSS" src="images/rss.gif"/><br/>
						<div style="text-decoration:underline;display:inline">Подписаться на RSS</div></a>
					</div>
                    
                  

			</div>

       

			<!-- end: #col1 -->
			<!-- begin: #col3 static column -->
			<div id="col3">
				<div id="col3_content" class="clearfix"> <a id="content" name="content"></a>





<script>

            function go_event_comment(act, id)
            {
                 document.s_article.activity.value = act;
                 document.s_article.id.value = id;
                document.s_article.submit();
            }


            function go_event_vote(act, id)
            {
                 document.v_article.activity.value = act;
                 document.v_article.id.value = id;
                document.v_article.submit();
            }
            
            
</script>

<h2 style="margin-bottom:3px">Параллельная генерация пространства состояний дискретных детерминированных моделей</h2><div style="margin-bottom:10px"><strong>Parallel statespace generation for finite discrete models</strong></div>Статья опубликована в выпуске журнала № 4 за 2010 год. [ 09.12.2010 ]<br/><strong>Аннотация:</strong><em style="font-size:8pt">Основной проблемой проверки конечных моделей является комбинаторный взрыв числа состояний, которые с ростом размера модели становится трудно хранить в ОЗУ одной машины. Рассматривается подход к проверке моделей на основе параллельной генерации состояний и их распределенного хранения. Предлагается схема распределенного хранения состояний, позволяющая уменьшить число удаленных вызовов между узлами в процессе генерации. Приводятся результаты экспериментов, полученные при помощи разработанного программного средства.</em><br /><strong>Abstract:</strong><em style="font-size:8pt">A major limitation of model-checking is statespace combinatorial explosion, which makes even medium-sized model inappropriate for that kind of verification. In this paper, parallel statespace generation with distributed state storage is proposed as a possible solution. State partitioning scheme that allows to reduce number of remote calls during generation process is developed. Experimental results, produced by developed verification tool, are given and prove that proposed partitioning scheme is better than random uniform distribution.</em><table border="0" width="100%" style="width:100%;"> 
            <tr>
             <td colspan="2"><b>Автор: </b><a href="index.php?page=infou&id=5921">Коротков И.А. ()</a> -    </td>            
         </tr> 
            <tr>
             <td><b>Ключевые слова: </b><a href="index.php?page=infotg&id=1746">язык promela</a>, <a href="index.php?page=infotg&id=1744">проверка моделей</a>, <a href="index.php?page=infotg&id=1044">параллельные вычисления</a>, <a href="index.php?page=infotg&id=1745">генерация состояний</a>, <a href="index.php?page=infotg&id=1743">: формальная верификация</a><br /></td> 
           </tr>
            <tr>
             <td><b>Keywords: </b><a href="index.php?page=infotg&id=1746"></a>, <a href="index.php?page=infotg&id=1744"></a>, <a href="index.php?page=infotg&id=1044">parallel computing</a>, <a href="index.php?page=infotg&id=1745"></a>, <a href="index.php?page=infotg&id=1743"></a><br /></td> 
           </tr>   

 <tr>
             <td>Средний балл статьи: - <br />Всего комментариев: 0<br />Количество просмотров: 71<br />   
             </td> 
            <td align="right"><a target="_blank" href="/print/article_print.php?id=2601">Версия для печати</a></td>
         </tr>           
          </table>

<br/>

    
    
    <script>
      function set_size(vl) {
         document.getElementById('id_art').style.fontSize = vl;
      }
      function set_font(vl) {
         document.getElementById('id_art').style.fontFamily = "'" + vl + "'";
      }
    </script>
    
      <div style="width:100%;background:#E0E0E0;padding:5px;border:1px solid #D0D0D0">
         <form>
           Размер шрифта:
            <select name="f_size" onchange="set_size(this.value)">
               <option value="10px">10 px</option>
               <option value="12px" selected="selected">12 px</option>
               <option value="14px">14 px</option>
               <option value="16px">16 px</option>
               <option value="18px">18 px</option>
               <option value="24px">24 px</option>
            </select> &nbsp; &nbsp; &nbsp;
           Шрифт:
            <select name="f_name" onchange="set_font(this.value)">
               <option value="Arial">Arial</option>
               <option value="Trebuchet MS" selected="selected">Trebuchet MS</option>
               <option value="Times New Roman">Times New Roman</option>
               <option value="Verdana">Verdana</option>
               <option value="Arial Narrow">Arial Narrow</option>
               <option value="Tahoma">Tahoma</option>
            </select>
            
         </form>
        </div>
         <br />
    <table bgcolor="#FFFFFF"><tr><td><div id="id_art" style="font-size:12px;"><p>При разработке сложных параллельных систем (систем, состоящих из нескольких асинхронно работающих компонент) с высокой степенью надежности зачастую бывает недостаточно традиционных подходов к тестированию, поскольку они позволяют выявлять лишь легко воспроизводимые ошибки. В некоторых случаях, например, в ПО для бортовых систем, определенные классы ошибок требуется полностью исключить.</p>
<p>&nbsp;</p>
<p>Для этого осуществляется проверка модели (model checking) &ndash; автоматический формальный подход, при котором на основе дискретной детерминированной модели программы или комплекса программ строится полное пространство состояний и на нем проверяется набор интересующих утверждений &ndash; спецификация [1].</p>
<p>Проверку моделей можно использовать для поиска взаимоблокировок в параллельных алгоритмах и ошибок в спецификациях сетевых прото&shy;колов. В качестве примера можно привести прото&shy;кол маршрутизации RIP: проверка модели сети из четырех маршрутизаторов, соединенных четырьмя сетевыми интерфейсами, на возникновение циклов в маршрутных таблицах позволяет убедиться, что существуют сценарии, при которых такие циклы возникают, и необходимо принять специальные меры (расщепленный горизонт) для их избежания.</p>
<p>Формальное описание проверки моделей. Пространство состояний моделируемой программы или программного комплекса можно формализовать как модель Крипке (структуру Крипке). Моделью Крипке M над множеством атомарных высказываний AP называют четверку M=(S, S0, R, L), где S &ndash; конечное множество состояний; S0&Icirc;S &ndash; множество начальных состояний; R&Icirc;S&acute;S &ndash; отношение переходов, обязанное быть тотальным, то есть для каждого состояния s&Icirc;S должно существовать такое состояние s&cent;&Icirc;S, при котором имеет место R(s, s&cent;); L:S&reg;2AP &ndash; функция, помечающая каждое состояние множеством атомарных высказываний, истинных в этом состоянии.</p>
<p>Пусть в модели M состояние s &ndash; бесконечная последовательность состояний p=s0s1..., где s0=s и для всех i&sup3;0 выполняется R(si, si+1).</p>
<p>Моделируемый программный комплекс в каж&shy;дом своем состоянии описывается набором значений переменных V={s0, s1, &hellip;} на конечном множестве D (домене интерпретации), описывающих отдельные компоненты и взаимодействие между ними. Множество AP состоит из утверждений вида vi=di, где di&Icirc;D. Таким образом, каждое состояние s в M представляет собой отображение V&reg;D.</p>
<p>Отношение R определяется следующим образом. Пусть существуют два состояния &ndash; s1 и s2. Если в s1 имеется компонент, который может выполнить атомарный переход (изменение значений своих переменных), в результате чего система будет находиться в состоянии s2, значит, состояния s1 и s2 связаны отношением перехода (s1, s2)&Icirc;R. Если нет такого состояния s2, для которого выполнялось бы R(s1, s2), получается R(s1, s1), то есть тупиковое состояние s1, связанное отношением перехода самого в себя.</p>
<p><img src="uploaded/image/2010-4/image002.gif" alt="Подпись:  
Рис. 1" width="301" height="150" align="left" />Для формализации проверяемых на модели M утверждений обычно используются временные логики: LTL (linear time logic) &ndash; логика линейного времени, CTL (computation tree logic) &ndash; логика ветвящегося времени, CTL* &ndash; объединение LTL и CTL. Формулы в CTL* составляются из атомарных утверждений относительно значений переменных vi и кванторов: A (all) &ndash; для всех путей, выходящих из данного состояния; E (exists) &ndash; существует путь, выходящий из данного состояния; F (fina- lly) &ndash; рано или поздно в пути встретится состояние, в котором выполняется...; G (globally) &ndash; во всех состояниях пути выполняется...; X (next) &ndash; в следующем состоянии на данном пути выполняется...; U (until) &ndash; пока в пути не появится состояние, в котором выполняется y, во всех состояниях должно выполняться x.</p>
<p>Например, AFGx означает, что во всех путях, идущих из начального состояния, с некоторого состояния на протяжении всего пути выполняется x, а AGEF &ndash; во всех путях, идущих из начального состояния, из каждого состояния есть хотя бы один путь, в котором рано или поздно встретится состояние, в котором выполняется x.</p>
<p>Средство проверки модели SPIN. Это наиболее распространенное средство, использующее для описания исходной модели язык Promela (PROto&shy;col Meta Language).</p>
<p>Модель на языке Promela описывается в виде набора процессов, состоящих из последовательности команд. Каждый процесс имеет свой набор локальных переменных (в том числе счетчик команд). Для взаимодействия между процессами могут использоваться глобальные переменные и каналы (очереди сообщений). Каждая команда имеет свое условие выполнимости, и процесс считается заблокированным, если условие выполнимости его текущей команды не выполнено.</p>
<p>Приведем пример описания модели семафора Дейкстры и трех захватывающих его процессов в нотации Promela.</p>
<p>mtype { p, v };</p>
<p>chan sema = [0] of { mtype };</p>
<p>active proctype Dijkstra()</p>
<p>{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; byte count = 1;</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; do</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; :: (count == 1) -&gt;</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; sema!p; count--</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; :: (count == 0) -&gt;</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; sema?v; count++</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; od</p>
<p>}</p>
<p>active [3] proctype user()</p>
<p>{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; do</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; :: enter: sema?p; /* enter critical section */</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; crit: skip;&nbsp;&nbsp;&nbsp; /* critical section */</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; sema!v; /* leave critical section */</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; od</p>
<p>}</p>
<p>В ходе верификации SPIN выполняет исчерпывающий поиск в глубину по графу состояний (модели Крипке) и при обнаружении пути, на котором нарушается проверяемое утверждение, сохраняет его в качестве контрпримера. Если контрпример обнаружить не удается, верификация успешна. Функциональная схема процесса проверки модели изображена на рисунке 1.</p>
<p>Проблемы традиционного подхода. При росте числа и сложности компонент моделируемого программного комплекса происходит комбинаторный рост числа возможных состояний, поэтому проверка модели требует значительных вычислительных ресурсов. Приведенная в примере модель сети из четырех RIP-маршрутизаторов имеет более 109 состояний. Поскольку граф состояний в общем случае цикличен, необходимо хранить множество посещенных состояний, которое не помещается в ОЗУ одной машины, а использование внешней памяти приводит к увеличению времени проверки на 3&ndash;4 порядка.</p>
<p>Для сокращения числа состояний, а также тре&shy;буемого для их хранения объема ОЗУ применяется ряд оптимизаций: сокращение частных порядков (уменьшается размер графа состояний), битовое хэширование (уменьшается объем требуемой памяти за счет того, что сами состояния не хранятся и коллизии в хэш-таблице не отслеживаются) [2], сжатие состояний (уменьшается объем требуемой памяти, но незначительно и за счет существенного увеличения времени проверки). Однако все эти оптимизации либо дают небольшой, плохо масштабируемый прирост, либо приводят к потенциальным потерям состояний при обходе. Альтернативным подходом является параллельная генерация состояний с распределенным хранением по различным узлам вычислительной сети.</p>
<p>Параллельная генерация состояний. Возможны два подхода к параллельной генерации состояний.</p>
<p>1.&nbsp;&nbsp; <img src="uploaded/image/2010-4/image004.gif" alt="Подпись:  
Рис. 2. Пример работы распределенной 
генерации состояний" width="299" height="355" align="left" />Распределенное хранилище состояний. Состояния генерирует только один узел, а для хранения используются все узлы. Каждое состояние имеет свой&nbsp; однозначно вычисляемый номер узла, и для проверки принадлежности следующего состояния множеству посещенных делается синхронный удаленный вызов хранящего это состояние узла.</p>
<p>2.&nbsp;&nbsp; Распределенная генерация состояний. Каждый узел одновременно является и хранилищем, и генератором. Если новое состояние принадлежит другому узлу, оно высылается ему асинхронным удаленным вызовом. На рисунке 2 показан пример обхода графа при данном подходе. Цифры на нем обозначают локальный порядок генерации (в пределах данного узла).</p>
<p>Несмотря на очевидные преимущества (использование вычислительной мощности всех узлов, асинхронные вызовы вместо синхронных), у второго подхода есть недостаток &ndash; отсутствие какого-либо глобального порядка обхода состояний. Проверка определенных классов утверждений (например LTL-формул) требует поиска циклов в графе состояний, то есть обхода в глубину.</p>
<p>В данной статье рассматривается лишь генерация состояний, проблема нахождения таких циклов при распределенной генерации выходит за ее рамки и подробно рассмотрена в [3].</p>
<p>Распределение состояний между узлами. Функция распределения определяет для каждого состояния соответствующий индекс узла, отвечающего за хранение данного состояния.</p>
<p>Эта функция должна обладать следующими свойствами:</p>
<p>&middot;&nbsp;&nbsp;&nbsp;&nbsp; зависеть только от самого состояния (его битового представления), поскольку одно и то же состояние может генерироваться различными узлами в результате различных переходов;</p>
<p>&middot;&nbsp;&nbsp;&nbsp;&nbsp; распределять состояния между узлами достаточно равномерно, в противном случае часть памяти у некоторых узлов будет простаивать;</p>
<p>&middot;&nbsp;&nbsp;&nbsp;&nbsp; обладать локальностью относительно переходов между состояниями (по возможности новые состояния должны принадлежать тому же узлу, что и исходное).</p>
<p>Последнее условие имеет смысл лишь при распределенной генерации состояний и позволяет уменьшить число асинхронных удаленных вызовов между узлами.</p>
<p>Наиболее простым подходом является использование хэш-функции от битового представления состояния s в качестве индекса хранящего его узла. Это обеспечит первые два условия: если выбрана подходящая хэш-функция, распределение будет достаточно равномерным. Однако третье условие при этом не соблюдается, поскольку все новые состояния имеют равные шансы принадлежать любому узлу независимо от того, на каком из них они были сгенерированы.</p>
<p>Пусть число узлов &ndash; N, состояний &ndash; S, переходов между ними &ndash; T. При равномерном распределении состояний между узлами вероятность того, что следующее состояние будет принадлежать текущему узлу, равняется <img src="uploaded/image/2010-4/image006.gif" border="0" alt="" width="17" height="36" />. Следовательно, вероятность того, что потребуется удаленный вызов, равна <img src="uploaded/image/2010-4/image008.gif" border="0" alt="" width="33" height="36" />, а среднее число удаленных вызовов в течение всей генерации составит <img src="uploaded/image/2010-4/image010.gif" border="0" alt="" width="57" height="41" />, что при больших значениях N стремится к T.</p>
<p>Такое большое число удаленных вызовов негативно отражается на производительности, поэтому необходимо найти более удачную функцию распределения состояний, которая удовлетворяла бы условию локальности. Одна из возможных идей предложена в [4] &ndash; использовать хэш-код не от всего состояния s, а от некоторой его части s&cent;.</p>
<p>Битовое представление состояния в общем случае &ndash; это набор значений переменных, описывающих состояние отдельных компонент моделируемой системы, и значения общих переменных, описывающих взаимодействие между ними.</p>
<p>Пусть P &ndash; число таких компонент (процессов в нотации Promela) в модели; k &ndash; среднее число компонент, чье состояние затрагивается переходом (состояние которых меняется при переходе). Для языка Promela 1&raquo;k&lt;2, поскольку взаимодействие между более чем двумя процессами (далее под процессом будет подразумеваться процесс в понимании Promela, то есть компонент моделируемой системы) нереализуемо, но для двух процессов есть возможность синхронной передачи сообщения, при которой оба меняют свое состояние. Последняя возможность используется редко, поэтому для большинства моделей k достаточно близко к 1.</p>
<p>Таким образом, битовое представление состояния естественным образом разделяется на (P+1) область (учитывая область глобальных переменных), P из которых меняются почти независимо друг от друга (при условии k&raquo;1), и в качестве хэшируемого подсостояния s&cent; можно выбрать первые (или произвольные) r областей, хранящих локальные состояния (значения переменных) первых r процессов.</p>
<p>Если предположить, что каждый процесс pi участвует примерно в равном количестве переходов, то для произвольного, ранее заданного процесса вероятность участия в данном переходе составит <img src="uploaded/image/2010-4/image012.gif" border="0" alt="" width="16" height="36" />, а для r процессов при k&raquo;1 либо небольшом r &ndash; <img src="uploaded/image/2010-4/image014.gif" border="0" alt="" width="21" height="36" />. При условии, что множество возможных локальных состояний процесса отображается на множество узлов равномерно, вероятность удаленного вызова при изменении локального состояния процесса (то есть при его участии в переходе) по аналогии с предыдущими рассуждениями составит <img src="uploaded/image/2010-4/image008.gif" border="0" alt="" width="33" height="36" />. Таким образом, количество удаленных вызовов во всей модели равняется <img src="uploaded/image/2010-4/image017.gif" border="0" alt="" width="76" height="41" />&nbsp;и с ростом N стремится к <img src="uploaded/image/2010-4/image019.gif" border="0" alt="" width="32" height="36" />. При количестве процессов P=10, k=1,1 и r=2 число удаленных вызовов уменьшается примерно в 4 раза по сравнению с наивным подходом.</p>
<p>Выбор меньших значений r приводит к меньшему числу удаленных вызовов, однако увеличивает неравномерность распределения, поэтому его значение следует выбирать из баланса между требуемой равномерностью распределения состояний и выигрышем во времени за счет уменьшения числа вызовов.</p>
<p>Пусть i-й процесс r имеет wi возможных значений локального состояния (то есть число допустимых комбинаций значений его переменных составляет wi). Объединение локальных состояний r процессов тогда имеет не более <img src="uploaded/image/2010-4/image021.gif" border="0" alt="" width="68" height="37" />&nbsp;возможных значений (не все комбинации могут быть допустимыми). Значение r должно обеспечивать условие Wr&gt;&gt;N, иначе, особенно при Wr&raquo;N, распределение будет неравномерным даже при удачном выборе хэш-функции, а при Wr</p>
<p>Экспериментальная проверка. Создан прототип ПО для параллельной проверки состояний с распределенной генерацией, поддерживающий подмножество языка Promela для описания модели. Для задания проверяемых утверждений поддерживается подмножество LTL, допускающее формулы AGx и AFx, где x может содержать локальные переменные процессов (включая счетчик команд) и глобальные переменные. На практике данное подмножество LTL реализовано при помощи встроенной в Promela функции assert и поиска тупиковых состояний.</p>
<p>В качестве платформы для параллельных вычислений использовался стандарт MPI, выбранный в силу его распространенности среди кластерного ПО и поддержки широкого набора языков.</p>
<p>Исходными данными служат две модели: алгоритм выбора лидера и обедающие философы с числом компонент P=6. Для проведения экспериментов использовался кластер из 20 узлов, имеющих 4 Гб ОЗУ и 4 ЦПУ Intel Xeon 5120 1.86 ГГц каждый.</p>
<p>Результаты экспериментов по сравнению предлагаемого распределения с r=1 и r=2 с наивным (Н) представлены в таблице. Приведены следующие величины:</p>
<p>&middot;&nbsp;&nbsp;&nbsp;&nbsp; доля вызовов среди переходов &ndash; отношение числа удаленных вызовов (суммарно на всех узлах) к числу переходов T;</p>
<p>&middot;&nbsp;&nbsp;&nbsp;&nbsp; неравномерность распределения &ndash; отношение среднеквадратичного отклонения к среднему для последовательности m1, m2, &hellip;, mN, где mi &ndash; число состояний, хранимых узлом i;</p>
<p>&middot;&nbsp;&nbsp;&nbsp;&nbsp; время простоя при ожидании сообщений от других узлов (сетевые задержки);</p>
<p>&middot;&nbsp;&nbsp;&nbsp;&nbsp; общее время работы.</p>
<p>Сравнение распределений</p>
<table border="1" cellspacing="0" cellpadding="0" width="291">
<tbody>
<tr>
<td width="17" valign="top">
<p>r</p>
</td>
<td width="76" valign="top">
<p>Доля вызовов среди переходов, %</p>
</td>
<td width="85" valign="top">
<p>Неравномерность распределения, %</p>
</td>
<td width="53" valign="top">
<p>Время простоя, сек.</p>
</td>
<td width="66" valign="top">
<p>Общее время работы, сек.</p>
</td>
</tr>
<tr>
<td colspan="5" width="53" valign="top">
<p>Алгоритм выбора лидера</p>
</td>
</tr>
<tr>
<td width="17" valign="top">
<p>1</p>
</td>
<td width="76" valign="top">
<p>16</p>
</td>
<td width="85" valign="top">
<p>66,3</p>
</td>
<td width="53" valign="top">
<p>29</p>
</td>
<td width="66" valign="top">
<p>43</p>
</td>
</tr>
<tr>
<td width="17" valign="top">
<p>2</p>
</td>
<td width="76" valign="top">
<p>35</p>
</td>
<td width="85" valign="top">
<p>12,8</p>
</td>
<td width="53" valign="top">
<p>65</p>
</td>
<td width="66" valign="top">
<p>84</p>
</td>
</tr>
<tr>
<td width="17" valign="top">
<p>Н</p>
</td>
<td width="76" valign="top">
<p>87</p>
</td>
<td width="85" valign="top">
<p>0,1</p>
</td>
<td width="53" valign="top">
<p>127</p>
</td>
<td width="66" valign="top">
<p>164</p>
</td>
</tr>
<tr>
<td colspan="5" width="53" valign="top">
<p>Обедающие философы</p>
</td>
</tr>
<tr>
<td width="17" valign="bottom">
<p>1</p>
</td>
<td width="76" valign="top">
<p>17</p>
</td>
<td width="85" valign="top">
<p>89,4</p>
</td>
<td width="53" valign="top">
<p>3</p>
</td>
<td width="66" valign="top">
<p>14</p>
</td>
</tr>
<tr>
<td width="17" valign="bottom">
<p>2</p>
</td>
<td width="76" valign="top">
<p>35</p>
</td>
<td width="85" valign="top">
<p>29,6</p>
</td>
<td width="53" valign="top">
<p>7</p>
</td>
<td width="66" valign="top">
<p>21</p>
</td>
</tr>
<tr>
<td width="17" valign="bottom">
<p>Н</p>
</td>
<td width="76" valign="top">
<p>88</p>
</td>
<td width="85" valign="top">
<p>0,1</p>
</td>
<td width="53" valign="top">
<p>50</p>
</td>
<td width="66" valign="top">
<p>74</p>
</td>
</tr>
</tbody>
</table>
<p>Проблемные значения выделены жирным шрифтом.</p>
<p>Из результатов можно сделать следующие выводы.</p>
<p>1.&nbsp;&nbsp; Выбор распределения между узлами важен, поскольку время простоя за счет удаленных вызовов составляет существенную часть от времени выполнения.</p>
<p>2.&nbsp;&nbsp; При наивном подходе к распределению состояний число удаленных вызовов близко к числу всех переходов, как и следует из расчетов.</p>
<p>3.&nbsp;&nbsp; Предлагаемый способ распределения состояний по первым r процессам позволяет в несколько раз по сравнению с наивным подходом уменьшить число удаленных вызовов и время выполнения.</p>
<p>4.&nbsp;&nbsp; Необходим подбор параметра r в соответствии со свойствами проверямой модели (P, wi) для обеспечения требуемого уровня равномерности распределения состояний; в частности, значения r=1 в приведенных экспериментах оказалось недостаточно, поскольку неравномерность до 90&nbsp;% означает, что большая часть памяти некоторых узлов не используется вообще.</p>
<p>В заключение отметим, что использование параллельной генерации состояний дискретных детерминированных моделей в ходе проверки их соответствия спецификациям делает возможной верификацию моделей размера, на несколько порядков большего, чем позволяют традиционные подходы с последовательной генерацией. Одним из наиболее важных факторов является функция распределения хранимых состояний между узлами, правильный выбор которой, как подтверждают эксперименты, позволяет в несколько раз ускорить верификацию.</p>
<p>Литература</p>
<p>1.&nbsp;&nbsp; Кларк Э.М., Грамберг О., Пелед Д. Верификация моделей программ. МЦНМО, 2002.</p>
<p>2.&nbsp;&nbsp; Gerard J. Holzman. An Analysis of Bitstate Hashing. In proc. 15th Int. Conf. on Protocol Specifi&shy;cation, Testing, and Verification. Kluwer, 1998, pp. 301&ndash;314.</p>
<p>3.&nbsp;&nbsp; Jiri Barnat, Lubos Brim. Parallel Breadth-First Search  LTL Model-Checking. 18th IEEE International Conf. on Auto- mated Software Engineering (ASE'03). Springer, Berlin, 2003,  pp. 106&ndash;115.</p>
<p>4.&nbsp;&nbsp; Flavio Lerda, Riccardo Sisto, Distributed-Memory Model Checking with SPIN, Lecture Notes In Computer Science // Springer, Berlin, 1999. Vol. 1680, pp. 22&ndash;39.</p></div><br /></td></tr></table><table border="0" width="100%" style="width:100%;">
                   <tr>
                      <td><b>Постоянный адрес статьи: http://swsys.ru/index.php?page=article&id=2601</b></td>
                      <td align="right"><a target="_blank" href="/print/article_print.php?id=2601">Версия для печати</a></td>
                   </tr>
                   <tr>
                      <td><b>Статья опубликована в выпуске журнала № 4 за 2010 год.</b></td>                      
                                  </tr>            <tr><td><a href="http://swsys.ru/pay/form.php?journal=92">Электронная подписка на данный выпуск в формате PDF</a>            </tr></td>              
          </table><br /><a href="javascript:history.back();">Назад, к списку статей</a><br /><br />Хотите оценить статью или опубликовать комментарий к ней - <a href="http://swsys.ru/index.php?page=registry">зарегистрируйтесь</a><br /><br />




				
				<div id="ie_clearing">&nbsp;</div>
				<!-- End: IE Column Clearing -->
				
			</div>
			<!-- end: #col3 -->
            
         
            
		</div>
        
		<!-- end: #main -->
		<!-- begin: #footer -->


         </div>


		<div id="footer">

			<div class="black">Журнал зарегистрирован в комитете РФ по печати</div><div style="margin:0px; padding:0px; line-height:16px">
			Свидетельство о регистрации средства массовой информации № 013831 от 26.11.99 г.<br />
			Решение Президиума Высшей аттестационной комиссии Министерства образования и науки РФ от 19.02.2010 г. (о внесении в Перечень ведущих рецензируемых научных журналов и изданий, в которых должны быть опубликованы основные научные результаты диссертаций на соискание ученых степеней кандидата и доктора наук).<br />
&copy; Все права на авторские материалы охраняются в соответствии с законодательством РФ. Перепечатка возможна только с разрешения редакции. При цитировании материалов обязательна ссылка на Международный журнал "Программные продукты и системы" (для on-line проектов обязательна гиперссылка).</div>
			

			<div style="margin-top:15px;float:left">
<!--LiveInternet counter--><script type="text/javascript"><!--
document.write("<a href='http://www.liveinternet.ru/click' "+
"target=_blank><img src='http://counter.yadro.ru/hit?t26.1;r"+
escape(document.referrer)+((typeof(screen)=="undefined")?"":
";s"+screen.width+"*"+screen.height+"*"+(screen.colorDepth?
screen.colorDepth:screen.pixelDepth))+";u"+escape(document.URL)+
";"+Math.random()+
"' alt='' title='LiveInternet: показано число посетителей за"+
" сегодня' "+
"border=0 width=88 height=15><\/a>")//--></script><!--/LiveInternet-->
			</div>

			<div align="right" style="margin:15px">
               <a target="_blank" href="http://www.cps.tver.ru">Сайт разработан в <span>НИИ &laquo;ЦЕНТРПРОГРАММСИСТЕМ&raquo;</span></a><br />
               <a href="http://swsys.ru/index.php?page=17">Информация о сайте</a>
            </div>

		</div>		
		<!-- end: #footer -->



	</div>

</div>



<style>

.reklama {
    color: #666;
   font-size:11px;
   font-family:Arial;
  padding-bottom:20px;
}
.reklama a {
    color: #666;
   text-decoration:underline;
}
.reklama a:hover {
    color: #000;
   text-decoration:none;
}
 

@media print {
  .reklama {
      display:none;
  }
}

</style>




</div>


 






<script type="text/javascript">
/*
var gaJsHost = (("https:" == document.location.protocol) ? "https://ssl." : "http://www.");
document.write(unescape("%3Cscript src='" + gaJsHost + "google-analytics.com/ga.js' type='text/javascript'%3E%3C/script%3E"));
*/
</script>
<script type="text/javascript">
/*
try {
var pageTracker = _gat._getTracker("UA-9821437-1");
pageTracker._trackPageview();
} catch(err) {}
*/
</script>

</body>
</html>
